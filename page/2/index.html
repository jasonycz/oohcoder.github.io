<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 2 页 | OohCode | 好奇的码农~</title>

  
  <meta name="author" content="sean chen">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="OohCode"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="OohCode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">OohCode</a>
    </h1>
    <p class="site-description">好奇的码农~</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2015/09/15/PHP-array-hash-key-overflow/"><span>PHP数组的key溢出问题</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/09/15/PHP-array-hash-key-overflow/" rel="bookmark">
        <time class="entry-date published" datetime="2015-09-15T02:52:49.000Z">
          2015-09-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>作为PHP最重要的数据类型HashTable其key值是有一定的范围的，如果设置的key值过大就会出现溢出的问题，下面根据其内部结构及实现原理详细探讨一下key值溢出问题。</p>
</blockquote>
<p>下面先给出一个key溢出的例子:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span>[<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line"><span class="variable">$arr</span>[<span class="number">18446744073708551617333333333333</span>] = <span class="string">'18446744073708551617333333333333'</span>;</span><br><span class="line"><span class="variable">$arr</span>[] = <span class="string">'test'</span>;</span><br><span class="line"><span class="variable">$arr</span>[<span class="number">4294967296</span>] = <span class="string">'test'</span>;</span><br><span class="line"><span class="variable">$arr</span>[<span class="number">9223372036854775807</span>] = <span class="string">'test'</span>;</span><br><span class="line"><span class="variable">$arr</span>[<span class="number">9223372036854775808</span>] = <span class="string">'test'</span>;</span><br><span class="line">var_dump(<span class="variable">$arr</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码的输出结果如下:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>(<span class="number">6</span>) &#123;</span><br><span class="line">  [<span class="number">1</span>]=&gt;</span><br><span class="line">  string(<span class="number">1</span>) <span class="string">"1"</span></span><br><span class="line">  [-<span class="number">999799117276250112</span>]=&gt;</span><br><span class="line">  string(<span class="number">32</span>) <span class="string">"18446744073708551617333333333333"</span></span><br><span class="line">  [<span class="number">2</span>]=&gt;</span><br><span class="line">  string(<span class="number">4</span>) <span class="string">"test"</span></span><br><span class="line">  [<span class="number">4294967296</span>]=&gt;</span><br><span class="line">  string(<span class="number">4</span>) <span class="string">"test"</span></span><br><span class="line">  [<span class="number">9223372036854775807</span>]=&gt;</span><br><span class="line">  string(<span class="number">4</span>) <span class="string">"test"</span></span><br><span class="line">  [-<span class="number">9223372036854775808</span>]=&gt;</span><br><span class="line">  string(<span class="number">4</span>) <span class="string">"test"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到当key值比较小是没有问题，当key值很大时输出的值溢出了，临界点是<code>9223372036854775807</code>这个数字。<br>下面分析一下原因 。首先我们先分析一下HashTable的结构(本文分析的是php-5.5.15版本的源码),可以通过源码看一下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file: Zend/zend_hash.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> bucket &#123;</span><br><span class="line">    ulong h;                        <span class="comment">/* Used for numeric indexing */</span> <span class="comment">/*对char *key进行hash后的值，或者是用户指定的数字索引值，可能会溢出*/</span></span><br><span class="line">    uint nKeyLength; <span class="comment">/*hash关键字的长度，如果数组索引为数字，此值为0*/</span></span><br><span class="line">    <span class="keyword">void</span> *pData; <span class="comment">/*指向value,一般是用户数据的副本，如果是指针数据，则指向pDataPtr*/</span></span><br><span class="line">    <span class="keyword">void</span> *pDataPtr; <span class="comment">/*如果是指针数据，此值会指向真正的value,同时上面pData会指向此值*/</span></span><br><span class="line">    <span class="keyword">struct</span> bucket *pListNext; <span class="comment">/*整个hash表的下一个元素*/</span></span><br><span class="line">    <span class="keyword">struct</span> bucket *pListLast; <span class="comment">/*整个hash表该元素的上一个元素*/</span></span><br><span class="line">    <span class="keyword">struct</span> bucket *pNext; <span class="comment">/*存放在同一个hash Bucket的下一个元素*/</span></span><br><span class="line">    <span class="keyword">struct</span> bucket *pLast; <span class="comment">/*同一个hash bucket的上一个元素*/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *arKey; <span class="comment">/*保存当前值所对于的key字符串,这个字段只能定义在最后,实现变长结构体*/</span></span><br><span class="line">&#125; Bucket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _hashtable &#123;</span><br><span class="line">    uint nTableSize; <span class="comment">/*hash Bucket的大小，最小为8，最以2*x增长*/</span></span><br><span class="line">    uint nTableMask; <span class="comment">/*nTableSize-1, 索引取值的优化*/</span></span><br><span class="line">    uint nNumOfElements; <span class="comment">/*hash Bucket中当前存在的元素个数， count()函数会直接返回此值*/</span></span><br><span class="line">    ulong nNextFreeElement; <span class="comment">/*下一个数字索引的位置*/</span></span><br><span class="line">    Bucket *pInternalPointer;   <span class="comment">/* Used for element traversal ,当前遍历的指针，foreach比for快的原因之一,这个指针指向当前激活的元素*/</span></span><br><span class="line">    Bucket *pListHead; <span class="comment">/*存储数组头元素指针*/</span></span><br><span class="line">    Bucket *pListTail; <span class="comment">/*存储数组尾元素指针*/</span></span><br><span class="line">    Bucket **arBuckets; <span class="comment">/*存储hash数组*/</span></span><br><span class="line">    <span class="keyword">dtor_func_t</span> pDestructor; <span class="comment">/*在删除元素时执行的回调函数，用于资源的释放*/</span></span><br><span class="line">    zend_bool persistent; <span class="comment">/*指出了Bucket内存分配的方式。如果persistent为TRUE，则使用操作系统本身的内存分配函数为Bucket分配内存，否则使用PHP的内存分配函数*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> nApplyCount; <span class="comment">/*标记当前hash Bucket被递归访问的次数(防止多次递归)*/</span></span><br><span class="line">    zend_bool bApplyProtection; <span class="comment">/*标记当前hash桶允许不允许多次访问。不允许时，最多只能递归3次*/</span></span><br><span class="line"><span class="preprocessor"># <span class="keyword">if</span> ZEND_DEBUG</span></span><br><span class="line">    <span class="keyword">int</span> inconsistent;</span><br><span class="line"><span class="preprocessor"># <span class="keyword">endif</span></span></span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure>
<p>假设我们已经对源码有了一定的了解了，我们可以知道<code>bucket.h</code>就是我们存储的key值，<code>bucket.h</code>的生成方法是根据<code>time33</code>算法获取的,对应到代码实现如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于字符串类型的key</span></span><br><span class="line">ZEND_API <span class="keyword">int</span> _zend_hash_add_or_update(HashTable *ht, <span class="keyword">const</span> <span class="keyword">char</span> *arKey, uint nKeyLength, <span class="keyword">void</span> *pData, uint nDataSize, <span class="keyword">void</span> **pDest, <span class="keyword">int</span> flag ZEND_FILE_LINE_DC)</span><br><span class="line">&#123;</span><br><span class="line">    ulong h;</span><br><span class="line">    uint nIndex;</span><br><span class="line">    Bucket *p;</span><br><span class="line"><span class="preprocessor"># <span class="keyword">ifdef</span> ZEND_SIGNALS</span></span><br><span class="line">    TSRMLS_FETCH();</span><br><span class="line"><span class="preprocessor"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IS_CONSISTENT(ht);</span><br><span class="line"></span><br><span class="line">    ZEND_ASSERT(nKeyLength != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    CHECK_INIT(ht);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//算出来hash key后需要根据hashTable的长度，把nIndex限制在这个长度内(通过nTableMask)</span></span><br><span class="line">    h = zend_inline_hash_func(arKey, nKeyLength);</span><br><span class="line">    nIndex = h &amp; ht-&gt;nTableMask;</span><br><span class="line"></span><br><span class="line">    p = ht-&gt;arBuckets[nIndex];</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于数字类型的key</span></span><br><span class="line">ZEND_API <span class="keyword">int</span> _zend_hash_index_update_or_next_insert(HashTable *ht, ulong h, <span class="keyword">void</span> *pData, uint nDataSize, <span class="keyword">void</span> **pDest, <span class="keyword">int</span> flag ZEND_FILE_LINE_DC)</span><br><span class="line">&#123;</span><br><span class="line">    uint nIndex;</span><br><span class="line">    Bucket *p;</span><br><span class="line"><span class="preprocessor"># <span class="keyword">ifdef</span> ZEND_SIGNALS</span></span><br><span class="line">    TSRMLS_FETCH();</span><br><span class="line"><span class="preprocessor"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IS_CONSISTENT(ht);</span><br><span class="line">    CHECK_INIT(ht);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是新增元素(如$arr[] = 'hello'), 则使用nNextFreeElement值作为hash值,否则直接使用传入的key h 最为hash值 */</span></span><br><span class="line">    <span class="keyword">if</span> (flag &amp; HASH_NEXT_INSERT) &#123;</span><br><span class="line">        h = ht-&gt;nNextFreeElement;</span><br><span class="line">    &#125;</span><br><span class="line">    nIndex = h &amp; ht-&gt;nTableMask;</span><br><span class="line"></span><br><span class="line">    p = ht-&gt;arBuckets[nIndex];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符串的hash函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> ulong <span class="title">zend_inline_hash_func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *arKey, uint nKeyLength)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> ulong hash = <span class="number">5381</span>; <span class="comment">//这个常量是哪儿来的？</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* variant with the hash unrolled eight times */</span></span><br><span class="line">    <span class="keyword">for</span> (; nKeyLength &gt;= <span class="number">8</span>; nKeyLength -= <span class="number">8</span>) &#123;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (nKeyLength) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">break</span>;</span><br><span class="line">EMPTY_SWITCH_DEFAULT_CASE()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面函数主要是插入或更新hashTable的函数，当插入的key是数字时，这个数字就是hastTable的索引值，其key值不经过hash算法，只经过<code>nIndex = h &amp; ht-&gt;nTableMask;</code>来确保存储的值范围属于hastTable的范围内，所以可以看出索引值<code>key</code> ,与其对应的时<code>nIndex</code>这个值，正在存储的槽位就是<code>nIndex</code>这个地方。</p>
<p>这个key类型是<code>ulong</code>，也就是<code>unsigned long</code>类型。由于我们的机器是64位的，所以<code>unsigned long</code>类型的取值范围应该是<code>0~1844674407370955161</code>。PHP有两个预定义的变量<code>PHP_INT_MAX</code>和<code>PHP_INT_SIZE</code>对于64位的机器他们的值分别是9223372036854775807和8，这恰好是hasttable所能表示key的最大值,到这里也许你会有一个疑问:为什么<code>PHP_INT_MAX</code>的值比<code>key</code>的范围不一致?<br>要回答这个问题首先要知道，hastTable的key输出可以是负值，这是怎么做到的呢？其实一个hashTable的hash值一定是一个正整数才行，但是输出的数和hash值只是一个对应关系，不需要都为正整数， 虽然我们定义的参数为<code>unsigned long</code>,其实我们却可以传一个负数,比如<code>$arr[-1] = &#39;test&#39;</code>，这时候也是和传递一个正数的处理过程是一样的。这时候<code>h</code>的值其实是<code>-1</code>的补码。再回到上面的问题，为什么<code>PHP_INT_MAX</code>的值比<code>key</code>范围不一致。当我们负值 PHP_INT_MAX时，其值是<code>9223372036854775807</code>，当赋值再比这个大时,输出的却是负数。这其实跟我们使用<code>var_dump</code>这个函数有关系, 下面代码是使用var_dump输出数组时所使用的方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">php_array_element_dump</span><span class="params">(zval **zv TSRMLS_DC, <span class="keyword">int</span> num_args, va_list args, zend_hash_key *hash_key)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    level = va_arg(args, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hash_key-&gt;nKeyLength == <span class="number">0</span>) &#123; <span class="comment">/* numeric key */</span></span><br><span class="line">        php_printf(<span class="string">"%*c[%ld]=&gt;\n"</span>, level + <span class="number">1</span>, <span class="string">' '</span>, hash_key-&gt;h);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* string key */</span></span><br><span class="line">        php_printf(<span class="string">"%*c[\""</span>, level + <span class="number">1</span>, <span class="string">' '</span>);</span><br><span class="line">        PHPWRITE(hash_key-&gt;arKey, hash_key-&gt;nKeyLength - <span class="number">1</span>);</span><br><span class="line">        php_printf(<span class="string">"\"]=&gt;\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    php_var_dump(zv, level + <span class="number">2</span> TSRMLS_CC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，当key为数字时输出的格式时<code>%ld</code>,值是<code>hash_key-&gt;h</code>，这就是问题所在了，存储的是一个<code>unsigned long</code>，输出的却是<code>long</code>，当值比<code>long</code>大时，自然输出的就是负数了。</p>
<p>总结: PHP的hastTable是通过链表法实现的，按说是不会存在溢出的问题，但是其索引值表示的范围有限，当超出索引值时就会造成溢出，这个溢出只存在当索引值为数字时，输入的数字为正，输出却为负值的原因是函数参数与输出的类型不一致导致的。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/php/">php</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/08/14/mean-primer/"><span>mean primer</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/08/14/mean-primer/" rel="bookmark">
        <time class="entry-date published" datetime="2015-08-14T06:57:05.000Z">
          2015-08-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="MEAN入门">MEAN入门</h1><h2 id="MEAN简介">MEAN简介</h2><h3 id="什么是MEAN?">什么是MEAN?</h3><p>根据<a href="http://meanjs.org/" target="_blank" rel="external">官方文档</a>, MEAN就是MongoDB +  Express +  AngularJS +  Node.js的组合。那么组成MEAN的各个部分又分别是什么? </p>
<ul>
<li><code>MongoDB</code>: 是一个基于分布式文件存储的NoSQL数据库。具体介绍和使用方法请参考<a href="http://docs.mongodb.org/manual/core/introduction/" target="_blank" rel="external">官方文档</a></li>
<li><code>Express</code>: 是一个简洁、灵活的Node.js Web应用开发框架。其实和PHP的MVC框架作用是一样的。详细介绍参见<a href="http://expressjs.com/" target="_blank" rel="external">官方文档</a></li>
<li><code>AngularJS</code>: 前端的MVC框架，更接近于 MVVM（Model-View-ViewModel)。具体介绍参考<a href="https://angularjs.org/" target="_blank" rel="external">官方文档</a></li>
<li><code>Node.js</code>: javascript的一个解析器，提供js在服务器端的运行环境。<a href="https://nodejs.org/" target="_blank" rel="external">官方网站</a></li>
</ul>
<h3 id="为什么是这个组合?">为什么是这个组合?</h3><p>大家已经熟悉了LAMP/LNMP的开发模式，这些开发模式已经能够满足了现在web开发的绝大部分需求。而新型的MEAN开发模式则是另外一个尝试,其目的是为了解决现在开发中的一些问题，是开发更加高效。总结起来主要有以下几个优点:</p>
<ul>
<li>Web服务器包含在了应用程序中，可以自动安装，部署过程得到了极大简化。</li>
<li>从传统数据库到NoSQL再到以文档为导向的持久存储MongoDB，使用户花费在编写SQL上的时间减少，有更多的时间编写js中的映射/化简功能。还能节省大量的转换逻辑(因为MongoDB存储的时JSON对象，js可以直接用)</li>
<li>得益于AngularJS,从传统的服务器端页面变为客户端单页面应用程序越来越方便。</li>
</ul>
<blockquote>
<p>以上内容参考来源:<a href="http://www.ibm.com/developerworks/cn/web/wa-mean1/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/web/wa-mean1/</a></p>
</blockquote>
<p>另外，任何开发模式都不是万能的，也就是没有银弹，这种开发模式可以給大家带来很多新的思想,开拓思路,对大家以后应对不同应用场景的需求是提供更多的参考。</p>
<h2 id="MEAN安装">MEAN安装</h2><p>MEAN只是一个组合，可以自己单独安装配置各个模块，也有现成的集成方案，如<a href="http://meanjs.org/" target="_blank" rel="external">meanjs</a>和<a href="http://mean.io/" target="_blank" rel="external">mean.io</a>(关于他们之间的区别可以参考stackoverflow上面的<a href="http://stackoverflow.com/questions/23199392/difference-between-mean-js-and-mean-io" target="_blank" rel="external">讨论</a>)。这里我们选择的是meanjs作为开发框架。</p>
<p>meanjs的安装可以参考<a href="http://meanjs.org/docs.html#getting-started" target="_blank" rel="external">官方文档</a>。这里需要提前介绍一下安装时用到的一些工具及安装遇到的问题和解决方案。</p>
<h3 id="常用工具">常用工具</h3><ul>
<li><code>npm</code>: 是Node Package Manage的简称,Node.js的包管理工具,它的主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布等。这个类似于centos系统上的yum工具. 可以通过package.json对npm进行配置。可以访问<a href="https://www.npmjs.com/" target="_blank" rel="external">官网</a>查看相关文档，也可以编写自己的npm包提交上去。(安利一下我写的一个很简单的包:<a href="https://www.npmjs.com/package/hexo-tag-plantuml" target="_blank" rel="external">https://www.npmjs.com/package/hexo-tag-plantuml</a>)</li>
<li><code>bower</code>: 也是包管理工具,由twitter推出.他和npm的区别是npm针对服务端的工具进行管理，bower则是主要管理前端页面的js依赖关系。通过bower.json和.bowerrc进行配置.</li>
<li><code>grunt</code>: 构建javascript的工具,可以自动的完成代码规范的检查，文件合并，文件压缩，单元测试等流程(参考这边文档<a href="http://www.cnblogs.com/chyingp/archive/2013/05/11/grunt_getting_started.html" target="_blank" rel="external">grunt从入门到自定义项目模板</a>).详细信息参考<a href="http://gruntjs.com/" target="_blank" rel="external">官网</a>。</li>
</ul>
<h3 id="安装流程">安装流程</h3><p>这部分上面提到的meanjs官网有详细的步骤，简单概况一下就是:</p>
<ol>
<li>安装Node.js&amp;npm, MongoDB, Bower, Grunt等</li>
<li>下载源码: <code>git clone https://github.com/meanjs/mean.git meanjs</code></li>
<li><p>进入meanjs目录，执行<code>npm install ; bower install</code>,执行bower使用会出现下面的提示:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Since bower is a user command, there is no need to execute it with superuser permissions.&#10;If you&#39;re having permission errors when using bower without sudo, please spend a few minutes learning more about how your system should work and make any necessary repairs.&#10;&#10;http://www.joyent.com/blog/installing-node-and-npm&#10;https://gist.github.com/isaacs/579814&#10;&#10;You can however run a command with sudo using --allow-root option</span><br></pre></td></tr></table></figure>
<p> 需要通过<code>bower install --allow-root</code>命令来执行安装。</p>
</li>
</ol>
<p>只需要这些，一个完成的网站就建成了。meanjs自带了一个博客登陆体系和博客浏览发布的功能。<br>在根目录下运行<code>grunt</code>命令就可以启动服务器了，默认的端口是3000，我们可以通过ip:3000的方式来访问这个网站。</p>
<h2 id="meanjs结构简介">meanjs结构简介</h2><p>首先进入根目录可以看到如下的文件内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[@tc_214_162 meanjs]# tree -aL 1&#10;.&#10;&#9500;&#9472;&#9472; app                     #&#21518;&#31471;MVC&#30340;&#20869;&#23481;&#30446;&#24405;&#10;&#9500;&#9472;&#9472; bower.json              #bower&#37197;&#32622;&#21253;&#31649;&#29702;&#30340;&#25991;&#20214;&#10;&#9500;&#9472;&#9472; .bowerrc                #&#37197;&#32622;&#23433;&#35013;&#36335;&#24452;&#10;&#9500;&#9472;&#9472; config                  #&#30456;&#20851;&#37197;&#32622;&#30446;&#24405;&#10;&#9500;&#9472;&#9472; .csslintrc&#10;&#9500;&#9472;&#9472; Dockerfile&#10;&#9500;&#9472;&#9472; .editorconfig&#10;&#9500;&#9472;&#9472; fig.yml                 &#10;&#9500;&#9472;&#9472; .git&#10;&#9500;&#9472;&#9472; .gitignore&#10;&#9500;&#9472;&#9472; gruntfile.js           #grunt&#30456;&#20851;&#37197;&#32622;&#10;&#9500;&#9472;&#9472; .jshintrc&#10;&#9500;&#9472;&#9472; karma.conf.js&#10;&#9500;&#9472;&#9472; LICENSE.md&#10;&#9500;&#9472;&#9472; node_modules          #node&#27169;&#22359;&#30340;&#23433;&#35013;&#30446;&#24405;&#10;&#9500;&#9472;&#9472; package.json          #npm&#21253;&#31649;&#29702;&#37197;&#32622;&#10;&#9500;&#9472;&#9472; Procfile&#10;&#9500;&#9472;&#9472; public                #&#21069;&#31471;&#20869;&#23481;&#10;&#9500;&#9472;&#9472; README.md&#10;&#9500;&#9472;&#9472; scripts               #&#29420;&#31435;&#33050;&#26412;&#30446;&#24405;&#10;&#9500;&#9472;&#9472; server.js             #&#26381;&#21153;&#36816;&#34892;&#30340;&#20837;&#21475;&#25991;&#20214;&#10;&#9500;&#9472;&#9472; .slugignore&#10;&#9492;&#9472;&#9472; .travis.yml</span><br></pre></td></tr></table></figure></p>
<p>后端MVC的主要结构如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app/&#10;&#9500;&#9472;&#9472; controllers    #C&#23618; &#10;&#9500;&#9472;&#9472; models         #M&#23618; &#10;&#9500;&#9472;&#9472; routes         #&#36335;&#30001;&#35268;&#21017;&#10;&#9500;&#9472;&#9472; tests&#10;&#9492;&#9472;&#9472; views          #V&#23618;</span><br></pre></td></tr></table></figure></p>
<p>前端主要结构如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public/&#10;&#9500;&#9472;&#9472; application.js        #&#24212;&#29992;&#20837;&#21475;&#10;&#9500;&#9472;&#9472; config.js             #&#24212;&#29992;&#37197;&#32622;&#10;&#9500;&#9472;&#9472; humans.txt&#10;&#9500;&#9472;&#9472; lib                   #angular&#30456;&#20851;&#24211;&#25991;&#20214;&#10;&#9500;&#9472;&#9472; modules               #angular&#19981;&#21516;&#27169;&#22359;&#10;&#9492;&#9472;&#9472; robots.txt</span><br></pre></td></tr></table></figure></p>
<p>angular的模块结构如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public/modules/&#10;&#9500;&#9472;&#9472; articles&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; articles.client.module.js&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; config&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; controllers         #angular&#30340;C&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; services            #angular&#30340;&#26381;&#21153;&#23618;&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; tests&#10;&#9474;&#160;&#160; &#9492;&#9472;&#9472; views               #V&#23618;&#10;&#9500;&#9472;&#9472; core&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; config&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; controllers&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; core.client.module.js&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; css&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; img&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; services&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; tests&#10;&#9474;&#160;&#160; &#9492;&#9472;&#9472; views&#10;&#9492;&#9472;&#9472; users&#10;    &#9500;&#9472;&#9472; config&#10;    &#9500;&#9472;&#9472; controllers&#10;    &#9500;&#9472;&#9472; css&#10;    &#9500;&#9472;&#9472; img&#10;    &#9500;&#9472;&#9472; services&#10;    &#9500;&#9472;&#9472; tests&#10;    &#9500;&#9472;&#9472; users.client.module.js&#10;    &#9492;&#9472;&#9472; views</span><br></pre></td></tr></table></figure></p>
<p>要相对上面的结构有清晰的了解，必须对熟悉各个模块的用法，还要了解一个页面从访问到展现的流程是怎么样。 下面通过一个页面的访问流程来对整个架构的工作流程有一个大概的认识。</p>
<h2 id="打开一个页面的流程">打开一个页面的流程</h2><p>为了便于我们假设你已经注册登录并创建了几篇文章，下面我们就依据对文章列表页的打开流程进行介绍。</p>
<ol>
<li><p>首先通过menu进入文章列表页:<code>http://localhost:3000/#!/articles</code>我们可以看到文章的列表。通过观察这个url可以看出，其实<code>#</code>是一个锚点，后台的部分只是hash参数，前面的才是真正的url,也就是我们其实访问的是根目录，通过访问日志也可以看出来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / 200 26.246 ms - -&#10;GET /modules/core/css/core.css 200 31.710 ms - 354&#10;GET /modules/users/css/users.css 200 26.138 ms - 211&#10;GET /lib/bootstrap/dist/css/bootstrap-theme.css 200 41.393 ms - -&#10;GET /lib/angular-resource/angular-resource.js 200 15.583 ms - -&#10;GET /lib/bootstrap/dist/css/bootstrap.css 200 81.453 ms - -&#10;GET /lib/angular-animate/angular-animate.js 200 36.241 ms - -&#10;GET /lib/angular-ui-utils/ui-utils.js 200 22.724 ms - -&#10;GET /lib/angular-bootstrap/ui-bootstrap-tpls.js 200 28.636 ms - -&#10;GET /lib/angular-ui-router/release/angular-ui-router.js 200 44.805 ms - -&#10;GET /config.js 200 24.392 ms - 791&#10;GET /application.js 200 37.393 ms - 1016&#10;GET /modules/articles/articles.client.module.js 200 30.888 ms - 133&#10;GET /modules/core/core.client.module.js 200 24.737 ms - 129&#10;GET /modules/users/users.client.module.js 200 18.616 ms - 129&#10;GET /modules/articles/config/articles.client.config.js 200 13.114 ms - 389&#10;GET /lib/angular/angular.js 200 161.376 ms - -&#10;GET /modules/articles/config/articles.client.routes.js 200 36.936 ms - 700&#10;GET /modules/articles/services/articles.client.service.js 200 25.093 ms - 295&#10;GET /modules/core/config/core.client.routes.js 200 19.327 ms - 384&#10;GET /modules/core/controllers/header.client.controller.js 200 13.791 ms - 495&#10;GET /modules/articles/controllers/articles.client.controller.js 200 34.063 ms - -&#10;GET /modules/core/controllers/home.client.controller.js 200 43.584 ms - 224&#10;GET /modules/users/config/users.client.config.js 200 31.473 ms - 708&#10;GET /modules/core/services/menus.client.service.js 200 39.634 ms - -&#10;GET /modules/users/config/users.client.routes.js 200 27.816 ms - -&#10;GET /modules/users/controllers/authentication.client.controller.js 200 22.157 ms - -&#10;GET /modules/users/controllers/password.client.controller.js 200 17.350 ms - -&#10;GET /modules/users/controllers/settings.client.controller.js 200 21.926 ms - -&#10;GET /modules/users/services/authentication.client.service.js 200 15.335 ms - 202&#10;GET /modules/users/services/users.client.service.js 200 9.742 ms - 244&#10;GET /lib/bootstrap/dist/css/bootstrap-theme.css.map 200 8.378 ms - 47721&#10;GET /lib/bootstrap/dist/css/bootstrap.css.map 200 49.468 ms - 390518&#10;GET /modules/articles/views/list-articles.client.view.html 200 8.756 ms - 819&#10;GET /modules/core/views/header.client.view.html 200 17.955 ms - -&#10;GET /articles 200 24.296 ms - 407&#10;GET /modules/core/img/brand/favicon.ico 200 12.350 ms - 32038</span><br></pre></td></tr></table></figure>
</li>
<li><p>请求到达之后首先会根据<code>app/routes</code>目录下面的路由规则进行匹配，<code>app/routes/core.server.routes.js</code>匹配到了这个路由,其内容入下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(app) &#123;&#10;    // Root routing&#10;    var core = require(&#39;../../app/controllers/core.server.controller&#39;);&#10;    app.route(&#39;/&#39;).get(core.index);&#10;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看出这个请求匹配到后交给了<code>core.index</code>进行处理,<code>app/controllers/core.server.controller.js</code>内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports.index = function(req, res) &#123;&#10;    res.render(&#39;index&#39;, &#123;&#10;        user: req.user || null,&#10;        request: req&#10;    &#125;);&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>index函数并接收到请求后对<code>&#39;index&#39;</code>模板进行了渲染,模板文件<code>app/views/index.server.view.html</code>内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &#39;layout.server.view.html&#39; %&#125;&#10;&#123;% block content %&#125;&#10;    &#60;section data-ui-view&#62;&#60;/section&#62;&#10;&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个模板继承了<code>layout</code>模板，并且重写了content的block内容。<br>我们再看一下被继承的模板<code>app/views/layout.server.view.html</code>其主要内容入如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;header data-ng-include=&#34;&#39;/modules/core/views/header.client.view.html&#39;&#34; class=&#34;navbar navbar-fixed-top navbar-inverse&#34;&#62;&#60;/header&#62;&#10;    &#60;section class=&#34;content&#34;&#62;&#10;        &#60;section class=&#34;container&#34;&#62;&#10;            &#123;% block content %&#125;&#123;% endblock %&#125;&#10;        &#60;/section&#62;&#10;    &#60;/section&#62;&#10;&#10;    &#60;!--Embedding The User Object--&#62;&#10;    &#60;script type=&#34;text/javascript&#34;&#62;&#10;        var user = &#123;&#123; user | json | safe &#125;&#125;;&#10;    &#60;/script&#62;&#10;&#10;    &#60;!--Application JavaScript Files--&#62;&#10;    &#123;% for jsFile in jsFiles %&#125;&#10;        &#60;script type=&#34;text/javascript&#34; src=&#34;&#123;&#123;jsFile&#125;&#125;&#34;&#62;&#60;/script&#62;&#10;    &#123;% endfor %&#125;&#10;&#10;    &#123;% if process.env.NODE_ENV === &#39;development&#39; %&#125;&#10;    &#60;!--Livereload script rendered --&#62;&#10;    &#60;script type=&#34;text/javascript&#34; src=&#34;http://&#123;&#123;request.hostname&#125;&#125;:35729/livereload.js&#34;&#62;&#60;/script&#62;&#10;    &#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的主要功是加载页面所需的js文件，这些文件的配置都在<code>config</code>里。根据上面的访问日志可以看出主要<code>public</code>下的js文件都被加载了。<br>到这里服务端的工作已经完成一半了。</p>
<ol>
<li>前端js加载后，angular就开始发挥作用了。angular也是一套MVC框架。在进入流程之前我们再次观察一下URL。我们打开主页时会发现url变成了<code>http://localhost:3000/#!/</code>。为什么url会自动加上这部分内容，又为什么需要加这部分内容呢？<br>根据官方文档<a href="https://docs.angularjs.org/guide/$location" target="_blank" rel="external">$locaiton</a> Hashbang and HTML5 Modes部分的介绍,这应该是和浏览器对history支持的兼容性有关系。具体介绍可以看文档。 angualr的路由匹配规则其实是从<code>#!</code>之后开始的。再回到本页，<code>public/modules/articles/config/articles.client.routes.js</code>匹配到了当前规则代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state(&#39;listArticles&#39;, &#123;&#10;url: &#39;/articles&#39;,&#10;templateUrl: &#39;modules/articles/views/list-articles.client.view.html&#39;&#10;&#125;).</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看出当匹配时，angualr会自动加载<code>templateUrl</code>到页面片上来，在观察一下被加载的页面片<code>public/modules/articles/views/list-articles.client.view.html</code>内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;section data-ng-controller=&#34;ArticlesController&#34; data-ng-init=&#34;find()&#34;&#62;&#10;    &#60;div class=&#34;page-header&#34;&#62;&#10;        &#60;h1&#62;Articles&#60;/h1&#62;&#10;    &#60;/div&#62;&#10;    &#60;div class=&#34;list-group&#34;&#62;&#10;        &#60;a data-ng-repeat=&#34;article in articles&#34; data-ng-href=&#34;#!/articles/&#123;&#123;article._id&#125;&#125;&#34; class=&#34;list-group-item&#34;&#62;&#10;            &#60;small class=&#34;list-group-item-text&#34;&#62;&#10;                Posted on&#10;                &#60;span data-ng-bind=&#34;article.created | date:&#39;mediumDate&#39;&#34;&#62;&#60;/span&#62;&#10;                by&#10;                &#60;span data-ng-bind=&#34;article.user.displayName&#34;&#62;&#60;/span&#62;&#10;            &#60;/small&#62;&#10;            &#60;h4 class=&#34;list-group-item-heading&#34; data-ng-bind=&#34;article.title&#34;&#62;&#60;/h4&#62;&#10;            &#60;p class=&#34;list-group-item-text&#34; data-ng-bind=&#34;article.content&#34;&#62;&#60;/p&#62;&#10;        &#60;/a&#62;&#10;    &#60;/div&#62;&#10;    &#60;div class=&#34;alert alert-warning text-center&#34; data-ng-if=&#34;articles.$resolved &#38;&#38; !articles.length&#34;&#62;&#10;        No articles yet, why don&#39;t you &#60;a href=&#34;/#!/articles/create&#34;&#62;create one&#60;/a&#62;?&#10;    &#60;/div&#62;&#10;&#60;/section&#62;</span><br></pre></td></tr></table></figure></p>
<p>页面加载后执行<code>find()</code>函数，这个函数在控制层文件<code>public/modules/articles/controllers/articles.client.controller.js</code>里可以看到:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scope.find = function() &#123;&#10;    $scope.articles = Articles.query();&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个函数调用了<code>Articels.query()</code>方法，这个方法是Angualr的一个注册的service(参考文档<a href="https://docs.angularjs.org/guide/services" target="_blank" rel="external">Services</a>), 位于文件<code>public/modules/articles/services/articles.client.service.js</code>中，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//Articles service used for communicating with the articles REST endpoints&#10;angular.module(&#39;articles&#39;).factory(&#39;Articles&#39;, [&#39;$resource&#39;,&#10;    function($resource) &#123;&#10;        return $resource(&#39;articles/:articleId&#39;, &#123;&#10;            articleId: &#39;@_id&#39;&#10;        &#125;, &#123;&#10;            update: &#123;&#10;                method: &#39;PUT&#39;&#10;            &#125;&#10;        &#125;);&#10;    &#125;&#10;]);</span><br></pre></td></tr></table></figure></p>
<p>看到并没有定义<code>query</code>方法,是因为这方法是<code>$resource</code>默认的(参考<a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank" rel="external">$resource</a>),代码中<code>articleId</code>是参数，本次查询并没有传递参数，所以实际访问的url是<code>/articles</code>,这个是一个RESTful接口，返回的结果赋值給<code>$scope.articles</code>,就可以在前端正常展示文章列表了。</p>
<ol>
<li>第3步的最后提到了访问<code>/articles</code>接口，这个接口的作用就是从数据库取数据然后在返回到前端。当访问接口时，服务器接到请求,文件<code>app/routes/articles.server.routes.js</code>匹配到路由规则：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.route(&#39;/articles&#39;)&#10;    .get(articles.list)&#10;    .post(users.requiresLogin, articles.create);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由于是get方法，所以需求转给了<code>articles.list</code>方法进行处理，<code>app/controllers/articles.server.controller.js</code>中<code>list</code>方法代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports.list = function(req, res) &#123;&#10;    Article.find().sort(&#39;-created&#39;).populate(&#39;user&#39;, &#39;displayName&#39;).exec(function(err, articles) &#123;&#10;        if (err) &#123;&#10;            return res.status(400).send(&#123;&#10;                message: errorHandler.getErrorMessage(err)&#10;            &#125;);&#10;        &#125; else &#123;&#10;            res.json(articles);&#10;        &#125;&#10;    &#125;);&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>Articles</code>这个对象是这个文件前面定义的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Article = mongoose.model(&#39;Article&#39;)</span><br></pre></td></tr></table></figure></p>
<p>其中<code>mongoose</code>是MongoDB的一个js封装库,这个module是在<code>app/models/article.server.model.js</code>下定义并注册的，代码如下:  </p>
<pre><code><span class="comment"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&#39;mongoose&#39;),&#10;    Schema = mongoose.Schema;&#10;&#10;/**&#10; * Article Schema&#10; */&#10;var ArticleSchema = new Schema(&#123;&#10;    created: &#123;&#10;        type: Date,&#10;        default: Date.now&#10;    &#125;,&#10;    title: &#123;&#10;        type: String,&#10;        default: &#39;&#39;,&#10;        trim: true,&#10;        required: &#39;Title cannot be blank&#39;&#10;    &#125;,&#10;    content: &#123;&#10;        type: String,&#10;        default: &#39;&#39;,&#10;        trim: true&#10;    &#125;,&#10;    user: &#123;&#10;        type: Schema.ObjectId,&#10;        ref: &#39;User&#39;&#10;    &#125;&#10;&#125;);&#10;&#10;mongoose.model(&#39;Article&#39;, ArticleSchema);</span><br></pre></td></tr></table></figure></span>
</code></pre><p>到这里，整个页面从访问到处理到返回数据和渲染页面的流程就完毕了。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/MEAN/">MEAN</a><a href="/tags/angularjs/">angularjs</a><a href="/tags/express/">express</a><a href="/tags/moongodb/">moongodb</a><a href="/tags/nodejs/">nodejs</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/05/28/http-cache/"><span>HTTP缓存机制</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/05/28/http-cache/" rel="bookmark">
        <time class="entry-date published" datetime="2015-05-28T08:38:39.000Z">
          2015-05-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>HTTP缓存是web开发中经常碰到的问题，但是之前虽然看过，那时候web开发刚开始做，概念有点儿模糊不清，所以重读了<a href="http://book.douban.com/subject/10746113/" target="_blank" rel="external">《HTTP权威指南》</a>的缓存部分。这里对自己的理解做一下记录。</p>
</blockquote>
<h2 id="为什么要缓存">为什么要缓存</h2><p>为什么要做缓存?如果你看到了这篇文章，其实心中肯定有了一个作缓存的需求和目标。缓存的目的无非就是提高用户体验，节省资源两方面。 </p>
<ul>
<li>提高用户体验:<br>从提高用户体验来讲，就是用户能够看到反馈的时间越短越好，速度越快越好。那么如何才能提高速度呢？当然是数据和用户越近越好，最好就在本地；还有就是网速越快越好，最好连接网络就能访问。我们都知道本地应用是最快的，因为所有的都在你的电脑里了，不需要再费劲去网上下载了。缓存的目的就是为了尽量完成这个工作而设计的。</li>
<li>节省资源:<br>这个怎么说呢，如果你要访问一个网站，第一次你肯定没有这些数据，但是如果访问后所有的数据都保存在了本地，或者离你很近的地方，就省得在网络的海洋漫游过来了，这当然就节省了不少流量，当然你的计费方式是按带宽来的，多少流量无所谓，可是对于提供网站服务的供应商来说这些都是白花花的银子啊，能剩就剩，<code>节约每一个铜板</code>嘛。  <h2 id="缓存的机制">缓存的机制</h2>这里只介绍基于HTTP协议的缓存。也许做web开发的都听过<code>expires</code>,<code>cache-control</code>,<code>If-Modified-Since</code>等缓存控制的HTTP头，这些眼花缭乱的头真让让人头晕啊，到底他们之间是什么关系，写了那么多，但是缓存是不是生效了？怎么生效的啊？带着这些疑问我也仔细阅读了一下书里的内容。其实一幅图可以说明很多问题:</li>
</ul>
<img src="http://www.plantuml.com/plantuml/svg/RL9DRzD05BpxLwp49JsOtcsfI4W88S49ReY3iTVOmlL6zYB1BK7GfZHfoeVIjB44eI54HRQX498sqFmPxzh-5zZUnevftcdtlT6RsPd5EZOW2F-y9sxtzgq7aJ-XFrw6Hw_ek1wETadlWjEWf42B0qcf5je46iPLONqT8Kr62hmkeqqEcWguXDbOiZ0dHDuyFl14Zjy0zDCPRNbqt8w-DiZXY7PziZ-apWxZZEQzgDyaZG7jk2Adgw3206HooW0trW3Me0agBw2zbgaGw76DZdTfvtjywf3pePXrJOGXiFGd6iwkQSMresY-BKko1daPcTX2HZuZxvhmULMte1rC1y7qXBW7r1ilTAI8z57fqknI28j-_oI3ZupyghQq-8VN7XlFu2D-8sy9jBqVNFJ2sI7nFjF69FpcY_cmK2w0ODgAdLeqh8T_tuOpXyLHG6sCgaoSOKDGCL71AWJJFUgqo9j-OlAbgrkj-AGP-VLLN7ahhV33w8xAtqEAhkfGuU_BkYd34YBnwwvaunmJkZkCv7-6acqBwt8bIHx1-TPgtz974FyiJvvsjcd_EFsBYwGP8-tzIZfBZ5UyoEoOBTcnDo7jZbXcShlazHV6L5AlgrnnAdOdgTuq9Fbf6klAvIL0UVloYErT-I7ITFy1">
<p>通过这个流程图我们可以看出有三个方向:</p>
<ol>
<li>未找到缓存(黑色线)<br>当没有找到缓存时，说明我们本地并没有这些数据，这种情况一般发生在我们首次访问网站，或者以前访问过，但是清除过缓存后。这时浏览器没有这些数据，浏览器就会先访问服务器，然后把服务器上的内容取回来，内容取回来以后，就要根据情况来决定是否要保留到缓存中了。这个地方与<code>cache-control</code>字段的内容有关系。</li>
<li>缓存未过期(蓝色线)<br>缓存未过期，指的是本地缓存没有过期，不需要访问服务器了，直接就可以拿本地的缓存作为响应在本地使用了。这样节省了不少网络成本，提高了用户体验过。这个内容跟<code>expires</code>字段和<code>cache-control</code>有密切的联系。</li>
<li>缓存已过期(红色线)<br>缓存过期，是根据<code>expires</code>和<code>cache-control</code>来判断的，当满足过期的条件时，会向服务器发送请求，发送的请求一般都会进行一个验证，目的是虽然缓存文档过期了，但是文档内容不一定会有什么改变，所以服务器返回的也许是一个新的文档，这时候的HTTP状态码是200,或者返回的只是一个最新的时间戳和304状态码。</li>
</ol>
<p>下面就针对这些情况和其对应的字段及字段的优先级进行性说明:<br>第一优先级<code>cache-control</code>(expires)。下面的表是从高到低的顺序优先级递减。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>no-store</td>
<td>不存储缓存数据，禁止对相应进行复制</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>no-cache</td>
<td>可以存储在本地缓存区中，但是必须进行新鲜度再验证满足之后才能使用</td>
</tr>
<tr>
<td>Pragma</td>
<td>no-cache</td>
<td>用在HTTP/1.0协议中，与Cache-control一样</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>must-revalidate</td>
<td>表示必须进行新鲜度的再验证之后才能使用,与no-cache的区别是，这个是在过期之后才会进行强制校验，一般用在没有使用cache-control等字段明确规定的缓存时，这时会自动使用缓存策略，如果不想自动缓存，则使用这个字段值(实际测试跟no-cache没什么区别)</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>max-age</td>
<td>相对存活时间，相对与Last-Modified的时间，如果当前时间与Last时间只差小于这个值，则不用访问服务器，直接使用缓存，否者要进行新鲜度校验</td>
</tr>
<tr>
<td>Expires</td>
<td>date</td>
<td>旧版本的使用方式，date是具体的过期时间,当没有cacche-control时使用</td>
</tr>
</tbody>
</table>
<p>上面这些主要是在本地进行的，主要作用就是决定用本地缓存还是用远程服务器的资源。下面有要介绍的是<code>新鲜度校验</code>阶段要用到的HTTP控制字段。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>If-Modified-Science</td>
<td>date</td>
<td>初始值与Last-Modified的值一样，当请求服务器时判断文件的Last-Modified，如果比现在的时间晚，证明做过修改，需要冲重新请求文档，返回的Last-Modified为最新的时间，下次次请求时，If-Modified-Science的值会更新到与Last-Modified一致,然后在发送请求.如果时间与现在的一样，证明那个没有更新，直接返回304状态码</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>date</td>
<td>表示的就是文档在服务器上的最后更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>版本号</td>
<td>前面的If-Modified-Science有一个缺点就是虽然文件的更新时间变了，但是内容并没有改变，也会重新发送文档，为了减少网络传输，这里就需要If-None-Match来判断了。主要是判断版本号与当前etag不一致时，更新文档，当Etag一致时只需更新文件更新时间就可以了</td>
</tr>
<tr>
<td>Etag</td>
<td>版本号</td>
<td>标识当前文档内容</td>
</tr>
</tbody>
</table>
<p>优先级: Etag &gt; Last-Modified 也就是说如果有Etag，就用If-None-Match来验证，否者才能用If-Modified-Science验证.</p>
<p>基本上常用的HTTP缓存功能就是这些。下面介绍一下在Nginx服务器先如何配置及前端页面如何访问和查看。</p>
<h2 id="怎么使用">怎么使用</h2><p>由于现在Nginx用的比较广泛，我用的也是Nginx，所以这里只介绍nginx的配置，其他服务器请google之。<br>首先是<code>expires</code>和<code>cache-control</code>的配置，参看<a href="http://nginx.org/en/docs/http/ngx_http_headers_module.html" target="_blank" rel="external">Nginx官方文档</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/http/">http</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/05/12/jekyll-to-hexo/"><span>从jekyll到hexo</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/05/12/jekyll-to-hexo/" rel="bookmark">
        <time class="entry-date published" datetime="2015-05-12T06:20:44.000Z">
          2015-05-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>最近把博客从jekyll迁移到了hexo，告一段落后写个总结，給后来的人一个参考。</p>
</blockquote>
<h2 id="为什么要迁移">为什么要迁移</h2><p>关于为什么把博客从 jekyll迁移到hexo，其原因其实跟这两个的优劣没有任何关系。每个人都有自己爱好，只要你用好了，其实本质上没什么差别，而我的原因则是因为最近团队前端人员极度缺人，只好让后台开发的人员也开始写js代码，不过自从写了js代码后我才发现js的天地是多么的广阔。通过写js代码我了解了的js语言的特性，以及前端的各种框架，比如<a href="http://requirejs.org/" target="_blank" rel="external">require.js</a>, <a href="http://www.gruntjs.net/" target="_blank" rel="external">grunt</a>, <a href="https://angularjs.org/" target="_blank" rel="external">angular</a>,<a href="http://expressjs.com/zh/" target="_blank" rel="external">express</a>等等，以及<a href="https://nodejs.org/" target="_blank" rel="external">Node.js</a>开发平台和包管理工具<a href="https://www.npmjs.com/" target="_blank" rel="external">npm</a>.最后当然还有本博客平台<a href="http://hexo.io/zh-cn/" target="_blank" rel="external">hexo</a>。<br>说回原因，其实就是因为我最近在学习js，而且对ruby不熟悉，所有我把博客迁移到了js的博客框架hexo。</p>
<h2 id="迁移过程中有哪些坑">迁移过程中有哪些坑</h2><p>根据hexo官方文档的<a href="http://hexo.io/zh-cn/docs/migration.html" target="_blank" rel="external">迁移说明</a>，其实很简单，只不过是把之前的<code>_posts/*</code>下的md文件都copy到hexo的<code>_post</code>下，然后把<code>new_post_name</code>改为<code>new_post_name: :year-:month-:day-:title.md</code>。看似很简单，但是实际情况却比这个要复杂些，主要是之前jekyll写博客的时候md文件会有很多内容在hexo平台不被识别，特别是jekyll用过某些插件后，hexo更不认识了。</p>
<h3 id="问题一:_高亮代码标签不兼容">问题一: 高亮代码标签不兼容</h3><p>jekyll中代码的高亮的tag是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% highlight %&#125;&#10;&#123;% endhighlight %&#125;</span><br></pre></td></tr></table></figure></p>
<p>而hexo中，高亮代码的tag是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock %&#125;&#10;&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个问题有两种解决方案，一种是用<code>sed</code>命令替换所有的jekyll高亮tag;第二种是自己写一个解析jekyll的tag插件.显然第一种方案更合适一些，所有我替换了所有的标签。  但是如果你想挑战自己，写一个插件也不错，可以copy hexo的codeblock插件代码，直接用到jekyll的tag上。</p>
<h3 id="问题二:_plantuml不支持">问题二: plantuml不支持</h3><p>为了画流程图我用了开源的流程图解决方案<a href="http://www.plantuml.com/" target="_blank" rel="external">plantuml</a>。但是jekyll其实原生也是不支持plantuml的，可以通过插件来解决，关于jekyll如何使用 plantuml的方法我也写过一篇介绍:<a href="http://oohcode.com/2013/12/30/jekyll-and-plugin-plantuml/">jekyll添加plantuml模块</a>.仍在使用jekyll的同学可以参考一下。<br>显然hexo原生也是不支持plantuml的，但是我一时也找不到支持plantuml的插件，所以如果博客一定要支持流程图摆在面前的选择只有两条路了: </p>
<ol>
<li>先画好流程图，然后博客中引入。</li>
<li>自己写一个支持plantuml的插件。<br>关于第一种解决方案，首先是麻烦，你需要提前生成各种图片，然后再引入进来，这会打断写博客的流程，同时也让人觉得很low。第二种解决方案，我研究了一下，发现并不难实现。下面就是plantuml插件实现的过程。  </li>
</ol>
<p>plantuml解析的两种方案:</p>
<ol>
<li>首先plantuml提供了java包，可以通过命令行把plantuml文件内容生成svg或png等格式的图片。</li>
<li>plantuml还提供了一个很好的平台，可以吧plantuml编码后直接作为参数访问,比如:<a href="http://plantuml.com:80/plantuml/png/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000" target="_blank" rel="external">http://plantuml.com:80/plantuml/png/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000</a><br>这种方法是实时计算出来后在plantuml平台生成图片后返回过来的。<br>下面对比这两种方法:</li>
</ol>
<table>
<thead>
<tr>
<th>方法&amp;特点</th>
<th>方法一：本地生成</th>
<th>方法二 ：同步生成</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>页面展示速度快</td>
<td>本地不需要保留任何图片</td>
</tr>
<tr>
<td>缺点</td>
<td>本地需要维护图片&amp;本地需要提前生产图片</td>
<td>页面图片展示比较慢</td>
</tr>
</tbody>
</table>
<p>再结合我们写博客的目的，是为了快速方面的使用，所以为了不维护一堆图片，考虑图片的名字等细节问题，我们干脆全放到web端，而且自己的服务器不一定比plantuml的快，所以性能的考虑可以忽略。最终我选择了同步生成的方式来解析plantuml标签。</p>
<p>hexo要添加tag的解析插件，可以参考hexo api文档<a href="http://hexo.io/zh-cn/api/tag.html" target="_blank" rel="external">标签插件</a>的介绍。其实就是注册插件，然后把tag里的内容当成参数传给tag处理函数，然后返回结果在页面上渲染。我们的这个hexo-tag-plantuml插件主要目的是把tag里的内容转化为plantuml的图片地址。正好plantuml提供了内容转化为图片的js <a href="http://www.plantuml.com/codejavascript.html" target="_blank" rel="external">API</a>，我其实就是把这些代码搬过来，然后根据hexo的tag插件写法实现的。具体源代码及用法请参考<a href="https://www.npmjs.com/package/hexo-tag-plantuml" target="_blank" rel="external">hexo-tag-plantuml</a>插件。</p>
<h3 id="其他问题">其他问题</h3><p>有问题时再更新……</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/01/27/php-internals-1/"><span>php内核系列1:PHP程序运行的入口</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/01/27/php-internals-1/" rel="bookmark">
        <time class="entry-date published" datetime="2015-01-26T16:00:00.000Z">
          2015-01-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>最近看了<a href="http://www.php-internals.com/book/" target="_blank" rel="external">深入理解PHP内核</a>这本书，并结合源码进行阅读。发现刚开始入门的时候很难，往往看了有点儿不知所云，因为虽然说了运行的周期，过程等，但是始终不明白的是:PHP程度的入口到底在哪里？不知道入口就没有起步，我始终走不下去。直到后来看<a href="http://www.php-internals.com/book/?p=chapt02/02-02-01-apache-php-module" target="_blank" rel="external">Apache模块</a>这章内容的时候才恍然大悟。这里就PHP的入口问题进行总结一下。</p>
</blockquote>
<h2 id="PHP入口">PHP入口</h2><p>首先回顾一下，我们使用PHP的方式有哪些?最常用的无非两种情况：</p>
<ul>
<li>与WEB服务器结合，在浏览器下运行。</li>
<li>命令行下直接运行PHP脚本文件。</li>
</ul>
<p>这两种方式的入口分别是什么呢？其实总结一下，就是下面三种入口。这点还可以从我们的PHP编译后的二进制文件找打足丝马迹，编译完PHP后我们会发现有一下几种二进制文件<code>php</code>, <code>php-cgi</code>等，没错，这些二进制文件就是PHP程序的入口。</p>
<h2 id="CLI">CLI</h2><p>我们知道PHP脚本可以直接在命令行下运行，像下面这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$php test.php</span><br></pre></td></tr></table></figure><br>其中<code>php</code>是PHP源代码编译后的二进制文件，当命令行执行php脚本时，其实是执行了源码<code>sapi/cli/php_cli.c</code>下的<code>main</code>函数, 这个函数大概内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ifdef PHP_CLI_WIN32_NO_CONSOLE&#10;int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)&#10;# else&#10;int main(int argc, char *argv[])&#10;# endif&#10;&#123;&#10;# ifdef ZTS&#10;    void ***tsrm_ls;&#10;# endif&#10;# ifdef PHP_CLI_WIN32_NO_CONSOLE&#10;    int argc = __argc;&#10;    char **argv = __argv;&#10;# endif&#10;&#10;    int c;&#10;    int exit_status = SUCCESS;&#10;    int module_started = 0, sapi_started = 0; &#10;    char *php_optarg = NULL;&#10;    int php_optind = 1, use_extended_info = 0; &#10;    char *ini_path_override = NULL;&#10;    char *ini_entries = NULL;&#10;    int ini_entries_len = 0; &#10;    int ini_ignore = 0; &#10;    sapi_module_struct *sapi_module = &#38;cli_sapi_module; //sapi&#32467;&#26500;&#10;&#10;    /*   &#10;     * Do not move this initialization. It needs to happen before argv is used&#10;     * in any way.&#10;     */&#10;    argv = save_ps_args(argc, argv);&#10;&#10;...&#10;...&#10;//&#26681;&#25454;&#21442;&#25968;&#36873;&#25321;&#22788;&#29702;&#31243;&#24207;&#10;    while ((c = php_getopt(argc, argv, OPTIONS, &#38;php_optarg, &#38;php_optind, 0, 2))!=-1) &#123;&#10;        switch (c) &#123;&#10;            case &#39;c&#39;:&#10;                if (ini_path_override) &#123;&#10;                    free(ini_path_override);&#10;                &#125;&#10;                ini_path_override = strdup(php_optarg);&#10;                break;&#10;            case &#39;n&#39;:&#10;                ini_ignore = 1;&#10;                break;&#10;            case &#39;d&#39;: &#123;&#10;                /* define ini entries on command line */&#10;                int len = strlen(php_optarg);&#10;                char *val;&#10;...&#10;...&#10;&#10;    /*&#10;     * Do not move this de-initialization. It needs to happen right before&#10;     * exiting.&#10;     */&#10;    cleanup_ps_args(argv);&#10;    exit(exit_status);&#10;&#125;</span><br></pre></td></tr></table></figure><br>具体这个函数是怎么执行的，我们先不关心，我们只是知道这个就是命令行下PHP代码执行的入口程序。</p>
<h2 id="Apache_Module">Apache Module</h2><p>Apache Module是按照Apache的编码规范，给Apapche写的module, 这些module在Apache服务器启动时会加载进来，并且加载进来的module可以执行执行的代码。关于这点<a href="http://www.php-internals.com/book/?p=chapt02/02-02-01-apache-php-module" target="_blank" rel="external">Apache模块</a>这里讲的更清楚。Apahce启动时其实就加载了mod_php5这个module,然后把请求传递给这个module进行处理，这就是PHP程序的入口。在<code>sapi</code>下我们可以发现一共有几个跟apache相关的目录<code>apache</code>, <code>apache2filter</code>, <code>apache2handler</code>, <code>apache_hooks</code>。这些都是apache相关的module，都会被apache调用。</p>
<h2 id="CGI">CGI</h2><p>上面说了apache调用php的方式，但是还有一种常见的方式就是cgi。我们知道cgi是通用网关接口，其实就是一种通信的协议。我们经常用的另外一个服务器nginx并没有专门的php module，那么这种服务器是怎么调用PHP处理程序的呢？就是用的CGI。<br>我们在使用nginx的会配置cgi，最常见的就是<code>fastcgi_pass   127.0.0.1:9000;</code>这个配置。其实nginx收到请求之后就会根据配置把请求都转发到了这个端口上，然后等处理完了返回时再交给nginx处理(epoll方式，参见nginx的网络模型)。其实真正调用php脚本的是cgi。php编译后会有一个<code>php-cgi</code>的二进制文件，这个就是php的cgi入口。但是一般情况下我们不是直接使用这个，主要是因为处理的请求很多，一个进程肯定处理不过来，需要对php-cgi进程进行管理财型，所以一般情况下我们使用的是<code>spawn-cgi</code>或<code>php-fpm</code>等，这些程序最大的作用就是管理cgi进程，关于他们的不同，这里就不说了。</p>
<h2 id="总结">总结</h2><p>开篇讲的就是PHP的入口，知道这个等于是入门了，以后阅读源码就是顺藤摸瓜了。根据PHP源码，我们可以看到，这些入口都放在一个<code>sapi</code>目录下，其实PHP的所有代码的执行都是通过SAPI(Server Application Programming Interface指的是PHP具体应用的编程接口)这个抽象层来完成的。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/PHP/">PHP</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/php/">php</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/" class="pagination-prev">上一页</a>
  
  
  <a href="/page/3/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2017 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>