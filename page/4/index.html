<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 4 页 | OohCode | 好奇的码农~</title>

  
  <meta name="author" content="sean chen">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="OohCode"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="OohCode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">OohCode</a>
    </h1>
    <p class="site-description">好奇的码农~</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2014/11/07/gdb-manual/"><span>GDB使用手册</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/11/07/gdb-manual/" rel="bookmark">
        <time class="entry-date published" datetime="2014-11-06T16:00:00.000Z">
          2014-11-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<blockquote>
<p>在学习C语言和学习源代码的过程中为了了解代码的运行过程，必须要DEBUG。GDB是一个不错的选择，有着强大的功能和成熟的技术。本博客记录GDB的各种使用方法，以便进行不断的学习总结。</p>
</blockquote>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/C/">C</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/GDB-DEBUG/">GDB DEBUG</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="2014/11/07/gdb-manual/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2014/07/05/coreseek-manual/"><span>coreseek使用手册</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/07/05/coreseek-manual/" rel="bookmark">
        <time class="entry-date published" datetime="2014-07-04T16:00:00.000Z">
          2014-07-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="产生文本摘要和高亮">产生文本摘要和高亮</h2><h3 id="函数原型:">函数原型:</h3><p><code>function BuildExcerpts ( $docs, $index, $words, $opts=array() )</code></p>
<h3 id="相关文档:">相关文档:</h3><p>(<a href="http://www.coreseek.cn/docs/coreseek_4.1-sphinx_2.0.1-beta.html#api-func-buildexcerpts" target="_blank" rel="external">官方文档</a>)<br>该函数用来产生文档片段（摘要）。连接到searchd，要求它从指定文档中产生片段（摘要），对命中词高亮，并返回结果。  </p>
<ul>
<li><code>$docs</code>为包含各文档内容的数组。必须把需要高亮的文本内容以数组的形式传入到函数中，最后输出的是标红后的文本摘要数组。</li>
<li><code>$index</code>为包含索引名字的字符串。给定索引的不同设置（例如字符集、形态学、词形等方面的设置）会被使用。</li>
<li><code>$words</code>为包含需要高亮的关键字的字符串。它们会按索引的设置被处理。例如，如果英语取词干（stemming）在索引中被设置为允许，那么即使关键词是“shoe”，“shoes”这个词也会被高亮。从版本0.9.9-rc1开始，关键字可以包含通配符，与查询支持的star-syntax类似。</li>
<li><p><code>$opts</code>为包含其他可选的高亮参数的hash表：</p>
<ul>
<li><code>&quot;before_match&quot;</code>:在匹配的关键字前面插入的字符串。从版本 1.10-beta开始，可以在该字符串中使用%PASSAGE_ID%宏。该宏会被替换为当前片段的递增值。递增值的起始值默认为1，但是可以通过</li>
<li><code>&quot;start_passage_id&quot;</code>设置覆盖。在多文档中调用时，%PASSAGE_ID%会在每篇文档中重新开始。默认为”<b>“。</b></li>
<li><code>&quot;after_match&quot;</code>:在匹配的关键字后面插入的字符串。从版本1.10-beta开始，可以在该字符串中使用%PASSAGE_ID%宏。默认为 ““。</li>
<li><code>&quot;chunk_separator&quot;</code>:在摘要块（段落）之间插入的字符串。默认为” … “.</li>
<li><code>&quot;limit&quot;</code>:摘要最多包含的符号（码点）数。整数，默认为256。</li>
<li><code>&quot;around&quot;</code>:每个关键词块左右选取的词的数目。整数，默认为 5.</li>
<li><code>&quot;exact_phrase&quot;</code>:是否仅高亮精确匹配的整个查询词组，而不是单独的关键词。布尔值，默认为false.</li>
<li><code>&quot;single_passage&quot;</code>:是否仅抽取最佳的一个区块。布尔值，默认为false.</li>
<li><code>&quot;use_boundaries&quot;</code>:是否跨越由phrase_boundary选项设置的词组边界符。布尔型，默认为false.</li>
<li><code>&quot;weight_order&quot;</code>:对于抽取出的段落，要么根据相关度排序（权重下降），要么根据出现在文档中的顺序（位置递增）。布尔型，默认是false.</li>
<li><code>&quot;query_mode&quot;</code>:版本1.10-beta新增。设置将<code>$words</code>当作 扩展查询语法的查询处理，还是当做普通的文本字符串处理（默认行为）。例如，在查询模式时，(“one two” | “three four”)仅高亮和包含每个片段中出现”one two” 或 “three four” 的地方及相邻的部分。而在默认模式时， 每个单独出现”one”, “two”, “three”, 或 “four”的地方都会高亮。布尔型，默认是false。</li>
<li><code>&quot;force_all_words&quot;</code>:版本1.10-beta新增. 忽略摘要的长度限制直至包含所有的词汇。布尔型，默认为false.</li>
<li><code>&quot;limit_passages&quot;</code>:版本1.10-beta新增. 限制摘要中可以包含的最大区块数。整数值，默认为 0 (不限制).</li>
<li><code>&quot;limit_words&quot;</code>:版本1.10-beta新增. 限制摘要中可以包含的最大词汇数。整数值，默认为 0 (不限制).</li>
<li><code>&quot;start_passage_id&quot;</code>:版本1.10-beta新增. 设置 %PASSAGE_ID% 宏的起始值 (在before_match, after_match 字符串中检查和应用). 整数值，默认为1.</li>
<li><code>&quot;load_files&quot;</code>:版本1.10-beta新增. 设置是否将$docs作为摘要抽取来源的数据（默认行为），或者将其当做文件名。从版本2.0.1-beta开始，如果该标志启用，每个请求将创建最多dist_threads个工作线程进行并发处理。布尔型，默认为false.</li>
<li><code>&quot;html_strip_mode&quot;</code>:版本1.10-beta新增. HTML标签剥离模式设置。默认为”index”，表示使用index的设置。可以使用的其他值为”none”和”strip”，用于强制跳过或者应用剥离，而不管索引如何设置的。还可以使用”retain”，表示保留HTMK标签并防止高亮时打断标签。”retain”模式仅用于需要高亮整篇文档，并且不能设置限制片段的大小。字符型，可用值为”none”，”strip”，”index”或者”retain”。</li>
<li><code>&quot;allow_empty&quot;</code>:版本1.10-beta新增. 允许无法产生摘要时将空字符串作为高亮结果返回 (没有关键字匹配或者不符合片段限制。). 默认情况下，原始文本的开头会被返回而不是空字符串。布尔型，默认为false.</li>
<li><p><code>&quot;passage_boundary&quot;</code>:版本2.0.1-beta新增. 确保区块不跨越句子，段落或者zone区域（仅当每个索引的设置启用时有效）。字符型，可用值为 “sentence”, “paragraph”, 或者 “zone”.”emit_zones”:版本2.0.1-beta新增. 在每个区块前使用区域对应的HTML标签来封闭区域。布尔型，魔默认为false。</p>
<p>摘要提取算法倾向于提取更好的片段（与关键词完全匹配），然后是不在摘要中但是包含了关键词的片段。 通常情况下，它会尝试高亮查询的最佳匹配，并且在限制条件下尽可能的高亮查询中的所有关键词。 如果文档没有匹配查询，默认情况下将根据限制条件返回文档的头部。从版本1.10-beta开始，可以通过设置allow_empty属性位true以返回空的片段来替代默认方式。<br>失败时返回false。成功时返回包含有片段（摘要）字符串的数组。</p>
</li>
</ul>
</li>
</ul>
<h3 id="使用方法">使用方法</h3><p>代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;?php&#10;//...&#30053;&#10;include(&#34;SphinxClient.php&#34;);&#10;class test&#123;&#10;&#10;&#10;    protected function make_words_highLight($source,$kw)&#123;&#10;&#10;&#10;        $cll = new SphinxClient ();&#10;        $opts = array&#10;            (&#10;                &#34;before_match&#34;      =&#62; &#34;&#60;span style=&#39;color:red&#39;&#62;&#34;,&#10;                &#34;after_match&#34;          =&#62; &#34;&#60;/span&#62;&#34;,&#10;                &#34;chunk_separator&#34;     =&#62; &#34; ... &#34;,&#10;                &#34;limit&#34;                =&#62; 10,&#10;                &#34;around&#34;               =&#62; 6,&#10;            );&#10;        $index = &#34;test1&#34;;&#10;        return $cll-&#62;BuildExcerpts($source,$index,$kw,$opts);&#10;    &#125;&#10;&#10;&#10;    //test&#10;    public function test()&#123;&#10;        $content = array(&#34;&#21271;&#20140;&#26159;&#20013;&#21326;&#20154;&#27665;&#20849;&#21644;&#22269;&#30340;&#39318;&#37117;&#34;,&#34;&#20013;&#22269;&#30340;&#39318;&#37117;&#26159;&#21271;&#20140;&#65292;2008&#22885;&#36816;&#20250;&#23601;&#22312;&#36825;&#37324;&#20030;&#21150;&#30340;&#34;,&#34;&#20140;&#19996;&#32769;&#26495;&#21016;&#24378;&#19996;&#34;);&#10;        $qsKey = &#34;&#21271;&#20140; &#19996;&#34;;&#10;        $contentArr = $this-&#62;make_words_highLight($content,$qsKey);&#10;        print_r($contentArr);die;&#10;    &#125;&#10;&#125;&#10;&#10;$m = new test();&#10;$m-&#62;test();&#10;&#10;?&#62;&#10;//&#36755;&#20986;&#32467;&#26524;&#10;Array&#10;(&#10;    [0] =&#62; &#60;span style=&#39;color:red&#39;&#62;&#21271;&#20140;&#60;/span&#62;&#26159;&#20013;&#21326;&#20154;&#27665;&#20849;&#21644;&#22269; ... &#10;    [1] =&#62;  ... &#39318;&#37117;&#26159;&#60;span style=&#39;color:red&#39;&#62;&#21271;&#20140;&#60;/span&#62;&#65292;2008 ... &#10;    [2] =&#62; &#20140;&#19996;&#32769;&#26495;&#21016;&#24378;&#60;span style=&#39;color:red&#39;&#62;&#19996;&#60;/span&#62;&#10;)</span><br></pre></td></tr></table></figure></p>
<h2 id="mmseg_同义词/复合分词处理">mmseg 同义词/复合分词处理</h2><h3 id="文档(官方文档)">文档(<a href="http://www.coreseek.cn/opensource/mmseg/#coreseek_mmseg_complex" target="_blank" rel="external">官方文档</a>)</h3><p>mmseg 3.2.13版本开始，提供了类似复合分词的处理方式，供coreseek进行调用。<br>其基本使用状况为：</p>
<ul>
<li>词库包含：<code>南京西路、南京、西路</code>(注意，一定要加入生成uni.lib的词库中)</li>
<li>索引时：文本中的“南京西路”会被同时索引为以上三者查</li>
<li>查询时：输入南京西路，可以直接匹配南京西路，而不匹配南京或者西路；输入南京或者西路，也可以搜索到南京西路</li>
</ul>
<p>用法：</p>
<ol>
<li>处理<code>unigram.txt</code>(在<code>mmseg3/etc</code>目录下)将词库加入，利用命令<code>mmseg -u unigram.txt</code> 生成新的词库<code>unigram.txt.uni</code>,用新的词库替代老词库<code>mv unigram.txt.uni uni.lib</code>(ps:被替换的同义词必须加入词库中，例如想让一个没有的词<code>测试</code>映射同义词<code>南京西路</code>则需要<code>南京西路</code>在词库中,<code>测试</code>不需要加入).</li>
<li><p>生成同义词库文件mmseg-3.2.13源代码<code>/script/build_thesaurus.py unigram.txt &gt; thesaurus.txt</code>(默认的同义词库，可自己修改).<br><code>thesaurus.txt</code>文件的格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#21335;&#20140;&#35199;&#36335;&#10;-&#21335;&#20140;,&#35199;&#36335;,&#10;&#24352;&#19977;&#20016;&#10;-&#22826;&#26497;&#23447;&#24072;,&#27494;&#24403;&#31062;&#24072;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成同义词词典:<code>mmseg -t thesaurus.txt</code>. 将<code>thesaurus.lib</code>放到<code>uni.lib</code>同一目录</p>
</li>
<li>停止索引服务searchd，重新建立索引，然后启动searchd (ps : 如果只是加入了新的同义词映射，没有修改词表的话不需要重启服务，只需重建索引即可)</li>
<li>coreseek索引和搜索时，会自动进行复合分词处理。搜索<code>南京</code>，<code>西路</code>时都能将搜索<code>南京西路</code>的结果匹配到</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/coreseek/">coreseek</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="2014/07/05/coreseek-manual/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2014/05/26/csapp-chapter8/"><span>csapp chapter8:异常控制流</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/05/26/csapp-chapter8/" rel="bookmark">
        <time class="entry-date published" datetime="2014-05-25T16:00:00.000Z">
          2014-05-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>程序运行的顺序是根据程序计数器（PC）的值而定的，PC从一个地址到另一个地址的过渡称为<em>控制转移(control transfer)</em>,这样的控制转移序列叫做处理器的<em>控制流(flow of control或 control flow)</em>。一般如果PC是按照顺序地址进行过渡的，控制流是一个平滑的序列，但是有些情况下PC是来回跳转的，这些突变称为<em>异常控制流(Exceptional Control Flow 简称EFC)</em>,EFC发生在计算机系统的各个层次。本章主要分析这种异常控制流。</p>
</blockquote>
<h2 id="异常">异常</h2><p>异常(exception)就是控制流中的突变,用来响应处理器状态中的某些变化。<br>下面通过一个图来理解异常.<br><img src="/assets/img/csapp/fig8.1.png" alt=""><br>可以看到程序在执行到<em> \(I_{curr}\) </em>时发生了一个异常，导致程序从原来该执行<em> \(I_{next}\)</em> ，变为了执行异常处理, 在执行完异常出理由程序后有下面三种可能：</p>
<ul>
<li>处理程序将控制返回给当前指令\(I_{curr}\), 即当事件发生时正在执行的命令。</li>
<li>处理程序将控制权返回给\(I_{next}\), 即如果没有发生异常将会执行的下一条指令。</li>
<li>处理程序终止被中断的程序。</li>
</ul>
<p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张<em>异常表</em>的跳转表,进行一个间接过程调用(异常)，到一个专门设计用来处理这类事件的操作系统子程序(异常处理程序(exception handler))。</p>
<h2 id="异常处理">异常处理</h2><p>系统为每个异常的类型都分配了一个唯一的非负整数的<em>异常号(exception number)</em>, 每个异常处理号都对应了一个异常处理程序，这些异常处理程序有些是处理器设计者分配的，有些事操作系统内核的设计者分配的，前者主要包括被零除，缺页，存储器访问违例、断点以及算术溢出，后者主要包括系统调用和来自外部I/O设备的信号。<br>在系统启动时，操作系统分配和初始化一张称为<em>异常表</em>的跳转表，如下：<br><img src="/assets/img/csapp/fig8.2.png" alt=""><br>这个图显示了如何利用根据异常号来找异常处理程序，并执行。  </p>
<p><strong>异常与过程调用的区别</strong>：</p>
<ul>
<li>异常调用时，在跳转处理器之前，处理器将返回地址压入栈中。返回地址是根据异常的类型而定的，可能是当前指令的地址，也可能是下一条指令的地址。过程调用一般入栈的是下一条指令的地址。</li>
<li>处理器把一些额外的处理器状态压到栈里，当处理程序返回时，重新开始被中断的程序会需要这些状态。</li>
<li>如果控制从一个用户程序转移到内核，那么所有的这些项目都被压入内核栈中，而不是压到用户栈中。</li>
<li>异常处理程序运行在内核模式下。这意味着它们对所有的系统资源具有完全的访问权限。</li>
</ul>
<p><strong>异常的类别</strong>:</p>
<ul>
<li><strong>中断</strong>:当前指令执行完后，会发现中断引脚的电压高了，就从系统总线读取处理程序。这种异常一般都是由外部的设备引起的，跟处理程序之间没有必然的联系，所以是异步的。下面的都是程序运行过程中自己有意或无意的引起的，所以事同步的行为。</li>
<li><strong>陷阱</strong>:是一个有意的异常，是执行一条指令引起的，引起异常的指令一般都是系统调用函数（如fork, single, exit, waitpid等），这些函数调用使程序从用户模式切换到了内核模式。</li>
<li><strong>故障</strong>:故障是由程序运行中的错误造成的，它能够被捕获并被故障处理程序修正。这种故障如缺页异常等。</li>
<li><strong>终止</strong>:这种异常一般是指不会恢复的致命错误。通常是一些硬件错误。</li>
</ul>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因</th>
<th>异步/同步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>来自I/O设备的信号</td>
<td>异步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>陷阱</td>
<td>有意的异常</td>
<td>同步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>故障</td>
<td>潜在可恢复的错误</td>
<td>同步</td>
<td>可能返回当前指令</td>
</tr>
<tr>
<td>终止</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不会返回</td>
</tr>
</tbody>
</table>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/CSAPP/">CSAPP</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="2014/05/26/csapp-chapter8/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2014/05/21/csapp-chapter7/"><span>csapp chapter7:链接</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/05/21/csapp-chapter7/" rel="bookmark">
        <time class="entry-date published" datetime="2014-05-20T16:00:00.000Z">
          2014-05-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>链接(linking)是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可以被加载（或拷贝）到存储器并执行。链接可以执行于编译时（compile time）,也就是在源代码被翻译成为机器代码时；也可以执行于加载时（load time），也就是在程序被加载器（loader）加载到存储器并执行时；甚至执行于运行时(rum time),由应用程序来执行。</p>
</blockquote>
<p>链接器使得分离编译(separate compilation)成为可能。本章将讨论从传统静态链接到加载时的共享库的动态链接，以及到运行时的共享库的动态链接。</p>
<h2 id="编译器驱动程序">编译器驱动程序</h2><p>通过一个例子来说明一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># main.c&#10;void swap();&#10;int buf[2] = &#123;1, 2&#125;;&#10;int main()&#10;&#123;&#10;    swap();&#10;    return 0;&#10;&#125;&#10;&#10;# swap.c&#10;extern int buf[];&#10;int *bufp0 = &#38;uf[0];&#10;int *bufp1;&#10;&#10;void swap()&#10;&#123;&#10;    int temp;&#10;    bufp1 = &#38;buf[1];&#10;    temp = *bufp0;&#10;    *bufp0 = *bufp1;&#10;    *bufp1 = temp;&#10;&#125;</span><br></pre></td></tr></table></figure><br>大多数系统提供<em>编译驱动程序(compiler driver)</em>,它代表用户在需要时调用语言预处理器，编译器，汇编器和链接器。<br>运行<code>gcc main.c swap.c -o p</code>命令都发生了什么？</p>
<ol>
<li>预处理器先将<code>main.c</code>和<code>swap.c</code>翻译成一个ASCII码的中间文件<code>main.i</code>和<code>swap.i</code></li>
<li>C编译器将<code>main.i</code>和<code>swap.i</code>翻译成ASCII汇编语言文件<code>main.s</code>和<code>swap.s</code></li>
<li>汇编器将<code>main,s</code>和<code>swap.s</code>翻译成<em>可重定定位的目标文件</em><code>main.o</code>和<code>swap.o</code></li>
<li>连接器程序ld将<code>main.o</code>和<code>swap.o</code>以及一些必要的系统目标文件组合起来，创建<em>可执行目标文件</em>p</li>
</ol>
<p>生产了可执行文件，可以通过过<code>./p</code>来运行，这是由外壳调用操作系统一个叫做<em>加载器</em>的函数,它拷贝可执行文件<code>p</code>中的代码和数据到存储器，然后将控制转移到这个程序的开头。</p>
<p>本章主要讲的是第4步的内容。</p>
<h2 id="静态链接">静态链接</h2><p>将一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。完成这种功能的是静态连接器，为了构造可执行文件，连接器必须完成两个主要任务：</p>
<ul>
<li><em>符号解析</em>(symbol resolution):目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联系起来。</li>
<li><em>重定位</em>(relocation):编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定为这些节。</li>
</ul>
<h2 id="目标文件">目标文件</h2><p>目标文件可以分为三种形式：</p>
<ul>
<li><em>可重定位目标文件</em>。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>
<li><em>可执行目标文件</em> 包含二进制代码和数据，其形式可以被直接拷贝到存储器链接并执行。</li>
<li><em>共享目标文件</em>：一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到存储器这并连接。</li>
</ul>
<h2 id="可重定位目标文件">可重定位目标文件</h2><p>一个典型的可重定位目标文件(ELF)的格式如下：<br><img src="/assets/img/csapp/fig7.3.png" alt="">  </p>
<ul>
<li>ELF头：包含生成该文件的系统的字的大小和字节顺序，以及帮助连接器分析和解释的目标文件的信息。</li>
<li>.text: 已编译程序的机器代码</li>
<li>.rodata: 只读数据，比如printf语句中的格式串和开关语句的跳转表</li>
<li>.data: <em>已初始化的全局C变量</em>。局部C变量在运行时保存在栈中。</li>
<li>.bass: <em>未初始化的全局C变量</em>。它仅仅是一个占位符，不占用磁盘空间。</li>
<li>.symtab: 一个<em>符号表</em>。它存放在程序中定义和引用的函数和全局变量的信息。</li>
<li>.rel.text: 一个.text节中位置的列表，当连接器把这个目标文件和其他文件结合时，需要修改这些位置。</li>
<li>.rel.data: 被模块引用或定义的任何全局变量和重定位信息。</li>
<li>.debug: 一个调试符号表。</li>
<li>.line: 原始C源程序中的行号和.text节中机器指令之间的映射。</li>
<li>.strtab:一个字符串表，其内容包括.symtab和.debug节中的符号表，及节头部中的节名字。<br>其中，每个部分都称为节**</li>
</ul>
<h2 id="符号和符号表(-symtab)">符号和符号表(.symtab)</h2><p>链接器的上下文中有三种不同的符号：</p>
<ul>
<li>由m定义并能被其他模块引用的全局符号。对应C语言中具有文件作用域并具有外部链接的变量</li>
<li>由其他模块定义并被模块m引用的全局符号。对应C语言中的变量与上面一样，并在本文件中用external声明</li>
<li>只被模块m定义和引用的本地符号。对应C语言中具有文件作用域但是具有内部链接的变量，如被static声明的全局变量。</li>
</ul>
<p>符号表包含一个数组，每个元素的结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;&#10;    int name; //&#23383;&#31526;&#20018;&#34920;(strtab)&#20013;&#30340;&#23383;&#33410;&#20559;&#31227;&#12290;&#10;    int value; //&#31526;&#21495;&#22320;&#22336;&#65292;&#26159;&#36317;&#23450;&#20041;&#30446;&#26631;&#30340;&#33410;&#30340;&#36215;&#22987;&#20301;&#32622;&#30340;&#20559;&#31227;&#12290;&#23545;&#21487;&#25191;&#34892;&#25991;&#20214;&#26469;&#35828;&#26159;&#19968;&#20010;&#32477;&#23545;&#36816;&#34892;&#26102;&#22320;&#22336;&#12290;&#10;    int size; //&#30446;&#26631;&#22823;&#23567;&#10;    int type:4, //&#26159;&#21464;&#37327;&#25110;&#32773;&#20989;&#25968;&#10;        binding:4; //&#34920;&#31034;&#26159;&#26412;&#22320;&#30340;&#36824;&#26159;&#20840;&#23616;&#30340;&#10;    char reserved; //&#20445;&#30041;&#30340;&#10;    char section; //&#34920;&#31034;&#31526;&#21495;&#21644;&#30446;&#26631;&#25991;&#20214;&#30340;&#26576;&#20010;&#33410;&#30456;&#20851;&#32852;,&#20063;&#23601;&#26159;&#36825;&#20010;&#31526;&#21495;&#22312;&#37027;&#20010;&#33410;&#20013;&#10;&#125; Elf_Symbol;</span><br></pre></td></tr></table></figure><br>看一下main.o的符号表中最后三个条目:</p>
<table>
<thead>
<tr>
<th>Num(name):</th>
<th>Value</th>
<th>Size</th>
<th>Type</th>
<th>Bind</th>
<th>Ot</th>
<th>Ndx(section)</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>8:</td>
<td>0(偏移为0)</td>
<td>8(8字节大小)</td>
<td>OBJECT(变量对象)</td>
<td>GLOBAL(全局的符号)</td>
<td>0</td>
<td>3(表示第三个节.data)</td>
<td>buf(符号名)</td>
</tr>
<tr>
<td>9:</td>
<td>0(偏移为0)</td>
<td>17(17字节大小)</td>
<td>FUNC(函数对象)</td>
<td>GLOBAL(全局的符号)</td>
<td>0</td>
<td>1(表示第一个节.text)</td>
<td>main(符号名)</td>
</tr>
<tr>
<td>10:</td>
<td>0</td>
<td>0</td>
<td>NOTYPE</td>
<td>GLOBAL</td>
<td>0</td>
<td>UND(表示外部符号引用)</td>
<td>swap(符号名)</td>
</tr>
</tbody>
</table>
<p>这个地方有点晕，因为前面说第一个是自己偏移，下面这个变成了name, 最有一个是符号名Name,但是上面结构中并没有说有这个字段, 表格中和结构中的字段写法不一样，实在是太难理解～<br>总而言之，符号表就是对每个符号的信息描述，这个符号表什么时候用呢？符号解析的时候。</p>
<h2 id="符号解析">符号解析</h2><p>链接器对多个可重定位目标文件进行解析的时候，读取每个文件的符号表，然后根据符号表的信息，与这个符号在代码中的确定的定义联系起来，目的是为了把所有的符号都合并在一起，形成一个完整的符号表，再加上其他信息，就变成了可执行文件。</p>
<p>这个过程在这里详细介绍一下，因为这里设计的链接器最核心的部分：如何变成可执行文件。</p>
<h3 id="链接器如何解析多重定义的全局符号">链接器如何解析多重定义的全局符号</h3><p>把符号分为强和弱。对于函数和已初始化的全局变量是<em>强符号</em>， 对于未初始化的变量是<em>弱符号</em>。unix链接器使用下面的规则来处理<em>多重定义</em>的符号：</p>
<ul>
<li>不允许有多个强符号</li>
<li>如果一个强符号和多个弱符号，那么选择强符号。</li>
<li>如果有多个弱符号，那么从这些弱符号中任意选择一个。</li>
</ul>
<h2 id="重定位">重定位</h2><p>一旦链接器完成了符号解析这一步，它就把代码中的每个符号引用和确定的一个符号定义（即它的一个输入目标模块中的一个符号表条目）联系起来。链接器根据输入目标模块中的代码节和数据节的确切大小，就可以开始重定位了：</p>
<ul>
<li>重定位节和符号定义：链接器将所有相同类型的节合并为同一类型的新的聚合节。然后链接器将<em>运行时存储器地址</em>赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。</li>
<li>重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器严重依赖称为<em>重定位条目</em>的可重定位目标模块中的数据结构。</li>
</ul>
<h3 id="重定位条目">重定位条目</h3><p>由于汇编器生成目标模块时，并不知道数据和代码最终将存放在存储器中的什么位置，所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个<em>重定位条目</em>，告诉链接器将目标文件合成可执行文件时如何修改这个引用。<br>代码的重定位条目放在.rel.text中。已初始化的数据重定位条目放在.rel.data中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;&#10;    int offset; //&#20559;&#31227;&#20301;&#32622;&#10;    in symbol:24, //&#25351;&#21521;&#24341;&#29992;&#30340;&#33410;&#10;        type:8; //&#37325;&#23450;&#20301;&#31867;&#22411;&#10;&#125;Elf32_Rel;</span><br></pre></td></tr></table></figure><br>重定位类型有11种，没种的实现方式不一样，这里只介绍两种最基本的：</p>
<ul>
<li>R_386_PC32: 使用一个32位PC（程序计数器）相对地址的引用。当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值加上PC的当前运行值，得到<em>有效地址</em>。</li>
<li>R_386_32: 重定位一个使用32位绝地地址的引用。通过绝对寻址，CPU直接使用在指令种编码 的32位值作为有效地址，不需要进一步修改。</li>
</ul>
<p>通过反汇编可执行文件，我们可看到重定位后的.text节的内容。</p>
<h2 id="可执行目标文件">可执行目标文件</h2><p>已经知道链接器将多个目标模块合并成一个可执行目标文件的。我们的C程序已经从ASCII码转化成了一个二进制文件，且这个二进制文件包含加载程序到存储器并运行它所需的所有信息。下图是一个典型的ELF可执行文件中的各类信息。<br><img src="/assets/img/csapp/fig7.11.png" alt=""><br>由于可执行文件是完全链接的(已被重定位)，所以它不再需要.rel节。我们发现还多了一个.init节，这个节定义了一个小函数，叫做_init,程序的初始化代码会调用它。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/CSAPP/">CSAPP</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="2014/05/21/csapp-chapter7/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2014/05/18/csapp-chapter6/"><span>csapp chapter6:存储器层次结构</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/05/18/csapp-chapter6/" rel="bookmark">
        <time class="entry-date published" datetime="2014-05-17T16:00:00.000Z">
          2014-05-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>存储器系统(memory system)是一个具有不同容量、成本和访问时间的存储设备的层次结构。程序如何利用存储器的特性提高性能呢？这将是本章主要探讨的内容。</p>
</blockquote>
<h2 id="存储技术">存储技术</h2><p>计算机的的成功很大程度上源自于存储技术的巨大进步。下面这幅图是存储器的层次结构：<br><img src="/assets/img/csapp/fig6.23.png" alt="">  </p>
<p>从上到下，存储的速度越慢，容量越大。<br>关于存储器内部是实现方式这就不介绍了，重点介绍一下计算机存储器的运行方式。<br>存储器层次结构的中心思想，对于每个<em>k</em>层，位于<em>k</em>层的更快更小的存储设备作为位于<em>k+1</em>层的跟大更慢的存储设备的缓存。也就是说层次结构中的<em>k</em>层的数据都是来自<em>k+1</em>层的。数据在每层之间的传送是以块大小为传送单元的。不同层之间的块大小可以不一样。程序运行过程中，对存储器的运用分为两种情况：</p>
<ul>
<li>缓存命中: 当程序需要数据时，最先从最高的层开始查找，如果没有找到了所需的数据，就是缓存命中。</li>
<li>缓存不命中: 当所需的数据从当前层没有找到，就叫缓存不命中。这时候就会从下一层开始查找，直到找到所需的数据为止。当找到所需的数据后，数据会再次经过上面的层，把找到的数据保存到上面的层中，这时就要覆盖上面层的数据，如何覆盖，这涉及到替换策略，不再详述。</li>
</ul>
<p>通过上面存储器的使用方式，可以看出，要想提高程序的性能，就必须利用<em>时间局部性</em>和<em>空间局部性</em>。</p>
<ul>
<li>时间局部性: 如果一个数据被加载到了最上层，那么如果连续多次调用这个数据就不需要去其他层寻找，减少了数据寻找和写缓存的过程，大大提高到了利用效率。</li>
<li>空间局部性： 但一个数被加载的最上层时，由于数据时以块大小进行传递的，所以这个数据相邻的地址数据也会被传递，所以如果这时候访问相邻的数据话，很有可能就在这一层，而不需要去其他层寻找数据，也大大提高了利用率。 </li>
</ul>
<p>下面通过一个程序来说明一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sum1(int a[M][N])&#10;&#123;&#10;    int i, j, sum = 0;&#10;&#10;    for(i = 0; i &#60; M; i++)&#10;        for(j = 0; j &#60; N; j++)&#10;            sum += a[i][j];&#10;    return sum;&#10;&#125;&#10;&#10;int sum2(int a[M][N])&#10;&#123;&#10;    int i, j, sum = 0;&#10;&#10;    for(j = 0; j &#60; M; j++)&#10;        for(i = 0; i &#60; N; i++)&#10;            sum += a[i][j];&#10;    return sum;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于sum1和sum2两个程序都时求一个二纬数组的和，唯一不同的是循环变量，也就是数组的下标顺序不一样。对于sum1，由于二纬数组是顺序存储的，而求和的时候也是按照递增的地址顺序求和的，这很好的利用了<em>空间局部性</em>这个原理，而sum2，同样是求和，但是二维数组的顺序并不是顺序访问的，又跳跃，所以每次访问的地址不是连续的，没有很好的利用<em>空间局部性</em>的原理，效率要低很多。<br>另一方面，两个程序的循环的过程中都使用了一个auto变量sum，每次循环都访问这个变量的值，这很好的利用了<em>时间局部性</em>原理。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/CSAPP/">CSAPP</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="2014/05/18/csapp-chapter6/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/3/" class="pagination-prev">上一页</a>
  
  
  <a href="/page/5/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2017 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>