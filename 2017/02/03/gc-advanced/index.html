<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>垃圾回收进阶算法 | OohCode | 好奇的码农~</title>

  
  <meta name="author" content="sean chen">
  

  
  <meta name="description" content="了解GC的基本算法后，还需要了解各种改进的GC算法，这些算法是在之前的基础上进行扩展和组合的。主要包括GC标记-压缩算法, 保守式GC, 分代垃圾回收， 增量式垃圾回收和RC Immix算法等。

GC标记-压缩算法GC标记-压缩算法(Mark Compact GC)是将GC标记-清除算法与GC复制">
  

  
  
  <meta name="keywords" content="gc">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="垃圾回收进阶算法"/>

  <meta property="og:site_name" content="OohCode"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="OohCode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">OohCode</a>
    </h1>
    <p class="site-description">好奇的码农~</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>垃圾回收进阶算法</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/02/03/gc-advanced/" rel="bookmark">
        <time class="entry-date published" datetime="2017-02-03T07:25:21.000Z">
          2017-02-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>了解GC的基本算法后，还需要了解各种改进的GC算法，这些算法是在之前的基础上进行扩展和组合的。主要包括<code>GC标记-压缩算法</code>, <code>保守式GC</code>, <code>分代垃圾回收</code>， <code>增量式垃圾回收</code>和<code>RC Immix算法</code>等。</p>
</blockquote>
<h2 id="GC标记-压缩算法">GC标记-压缩算法</h2><p>GC标记-压缩算法(Mark Compact GC)是将GC标记-清除算法与GC复制算法相结合的产物。 GC标记-压缩算法由标记阶段和压缩阶段构成。标记阶段和GC标记-清除算法提到的标记阶段一样。接下来需要搜索数次的堆来进行压缩。压缩阶段通过数次搜索堆来重新装填活动对象。</p>
<h3 id="Lisp2算法">Lisp2算法</h3><p>标记阶段的代码就不重复了，这里主要看压缩阶段的代码，下面可以看出压缩阶段主要分为三个步骤:</p>
<ol>
<li>第一步是<code>set_forwarding_ptr</code>, 主要是按顺序遍历堆内的活动对象，每个活动对象的<code>forwarding</code>指针指向的是以后这个活动对象需要移动到的位置。</li>
<li>第二步是<code>adjust_ptr</code>, 遍历整个活动对象，复制他们之间的引用关系, 这个步骤只更新指针。</li>
<li>第三步<code>move_obj</code>, 遍历整个堆，对活动对象进行移动。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">compaction_phase() &#123;</span><br><span class="line">    set_forwarding_ptr()</span><br><span class="line">    adjust_ptr()</span><br><span class="line">    move_obj()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_forwarding_ptr() &#123;</span><br><span class="line">    scan = new_address = $head_start</span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end)</span><br><span class="line">        <span class="comment"># 对被标记的对象，forwarding指针指向应该移动到的位置</span></span><br><span class="line">        <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line">            scan.forwarding = new_address</span><br><span class="line">            new_address += scan.size</span><br><span class="line">        <span class="comment"># 遍历整个堆</span></span><br><span class="line">        scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">adjust_ptr() &#123;</span><br><span class="line">    <span class="comment"># 移动根指针</span></span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        *r = (*r).forwarding</span><br><span class="line">    </span><br><span class="line">    scan = $head_start</span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end)</span><br><span class="line">        <span class="comment"># 每个活动对象，原来指向子节点的指针改为指向直接点的forwarding指向的地址</span></span><br><span class="line">        <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line">            <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">                *child = (*child).forwarding</span><br><span class="line">        scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">move_obj() &#123;</span><br><span class="line">    scan = $free = $head_start</span><br><span class="line">    <span class="comment"># 遍历堆</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end) </span><br><span class="line">        <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line">            new_address = scan.forwarding</span><br><span class="line">            <span class="comment"># 移动当前对象到对象forwarding指针指向的地址</span></span><br><span class="line">            copy_data(new_address, scan, scan.size)</span><br><span class="line">            <span class="comment"># 移动完活动对象后清空指针和标记，防止再次移动</span></span><br><span class="line">            new_address.forwarding = NULL</span><br><span class="line">            new_address.mark = FALSE</span><br><span class="line">            <span class="comment"># $free最终是压缩后可分配空间的开始</span></span><br><span class="line">            $free += new_address.size</span><br><span class="line">            scan += scan.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的步骤可以用下面的图形化的例子来描述:<br>首先假设原始状态如下:<br><img src="/assets/img/gc/gc_mc_list2_1.png" alt="原始状态"><br>先对其进行标记:<br><img src="/assets/img/gc/gc_mc_list2_2.png" alt="标记后"><br>设定forwarding指针:<br><img src="/assets/img/gc/gc_mc_list2_3.png" alt="设定forwarding指针"><br>更新指针:<br><img src="/assets/img/gc/gc_mc_list2_4.png" alt="更新指针"><br>移动对象:<br><img src="/assets/img/gc/gc_mc_list2_5.png" alt="移动对象"><br>上面可以看出，整个过程只是把活动对象往一边移动，活动对象之间的顺序不变。</p>
<ul>
<li>优点: 这个算法相对其他算法而言，堆利用率高，而且所有活动对象压缩到一端，不存在碎片化，能够充分的利用堆。</li>
<li>缺点: 整个压缩过程需要3遍对堆的搜索，也就是执行该算法所花费的时间与堆大小成正比，吞吐量要劣于其他算法。</li>
</ul>
<h3 id="Two-Finger算法">Two-Finger算法</h3><p>Two-Finger算法由两个步骤构成:</p>
<ol>
<li>移动对象</li>
<li>更新指针</li>
</ol>
<p>我们知道Lisp2算法是把所有对象向右滑动，不改变活动对象的顺序，而Two-Finger算法则是真正的移动对象，把后面的活动对象移动到前面的空间。为了防止对象相互覆盖，必须要将<code>所有对象整理成大小一致</code>, 这个该算法的一个前提条件。另外Lisp2算法需要单独设置forwarding指针，但是Two-Finger算法可以利用对象的域来设定forwarding指针，不要单独占空间。<br>两个步骤对象的伪代码如下, 要说明的是<code>move_obj</code>函数有两个指针:$free, 从头往后找，找空闲的空间； live，从后往前找，找活动对象。这两个指针就是Two-Finger的名称由来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">move_obj() &#123;</span><br><span class="line">    <span class="comment">#从头开始找空闲空间</span></span><br><span class="line">    $free = $heap_start</span><br><span class="line">    <span class="comment">#从尾开始找活动对象</span></span><br><span class="line">    live = $heap_end - OBJ_SIZE</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">        <span class="comment">#free, 是活动对像就略过,继续往后找</span></span><br><span class="line">        <span class="keyword">while</span>($free.mark == TRUE)</span><br><span class="line">            $free += OBJ_SIZE</span><br><span class="line">        <span class="comment">#live, 是活动对象就略过，继续往前找</span></span><br><span class="line">        <span class="keyword">while</span>(live.mark == FALSE)</span><br><span class="line">            live -= OBJ_SIZE</span><br><span class="line">        <span class="comment"># free 指针 比 live小，证明还没有结束，否则证明查找结束了</span></span><br><span class="line">        <span class="keyword">if</span>($free &lt; live)</span><br><span class="line">            <span class="comment">#把live指向的对象复制到free地址</span></span><br><span class="line">            copy_data($free, live, OBJ_SIZE)</span><br><span class="line">            <span class="comment">#live指向的对象的forwarding指针指向新地址，为下一步更新指针做准备</span></span><br><span class="line">            live.forwarding = $free</span><br><span class="line">            <span class="comment">#移动过的对象标记位FALSE</span></span><br><span class="line">            live.mark = FALSE</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">adjust_ptr() &#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        <span class="comment">#*r&gt;=$free的条件是对于被移动过的对象执行指针更新，没有移动过的对象保持原样</span></span><br><span class="line">        <span class="keyword">if</span>(*r &gt;= $free)</span><br><span class="line">            *r = (*r).forwarding</span><br><span class="line">        </span><br><span class="line">    scan = $head_start</span><br><span class="line">    <span class="comment">#scan &lt; $free 是因为对于大于scan的节点已经失效，只对当前活动对象更新</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $free)</span><br><span class="line">        <span class="comment">#更新过的标记一下</span></span><br><span class="line">        scan.mark = FLASE</span><br><span class="line">        <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">            <span class="comment">#*child &gt;= $free 的条件是对于被移动过的对象执行指针更新，</span></span><br><span class="line">            <span class="comment"># 没有移动过的对象保持原样</span></span><br><span class="line">            <span class="keyword">if</span>(*child &gt;= $free)</span><br><span class="line">                *child = (*child).forwarding</span><br><span class="line">        scan += OBJ_SIZE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点: 不需要额外的内存存储forwarding指针，内存使用效率比Lisp2高，只搜索两次堆，吞吐量也更好.</li>
<li>缺点: 压缩后对象的顺序发生了很大变化，不利于缓存的使用。而且每个对象大小必须一致，限制比较多。</li>
</ul>
<h3 id="表格算法">表格算法</h3><p>表格算法是综合了Lisp2和Two-Finger两种算法优点的算法。其主要步骤也是有两部分:</p>
<ol>
<li>移动对象(群)以及构筑间隙表格(break table)</li>
<li>更新指针</li>
</ol>
<p>前面两个每次都是移动一个活动对象，而在表格算法种每次移动的是一个群连续的活动对象，更新指针所有的信息也不再是forwarding指针，而是是有个一个叫间隙表格的方法。间隙表是由两个值组成的，其中每个表格代表的是一个活动对象群的入口，左值代表活动对象群的首地址，右值代表活动对象群所相邻的前面的空间占分块的总大小。<br>第一步过程可以用伪代码来表示:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">movie_obj()&#123;</span><br><span class="line">    <span class="comment">#从头开始遍历</span></span><br><span class="line">    scan = $free = $heap_start</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end)</span><br><span class="line">        <span class="keyword">while</span>(scan.mark == FLASE)</span><br><span class="line">            <span class="comment"># size 记录相邻的非活动对象的大小</span></span><br><span class="line">            size += scan.size</span><br><span class="line">            scan += scan.size</span><br><span class="line">        <span class="comment"># 记录活动对象的首地址</span></span><br><span class="line">        live = scan</span><br><span class="line">        <span class="keyword">while</span>(scan.mark == TRUE)</span><br><span class="line">            scan += scan.size</span><br><span class="line">        <span class="comment"># 上面两个while后，找到了第一个连续的非活动空间和第一个连续的活动空间</span></span><br><span class="line">        <span class="comment"># 移动活动对象群，并构筑间隙表格</span></span><br><span class="line">        slide_objs_and_make_bt(scan, $free, live, size)</span><br><span class="line">        <span class="comment"># 移动后记录下一个空闲空间地址</span></span><br><span class="line">        $free += (scan -live)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>slide_objs_and_make_bt</code>函数是一个比较复杂的过程，它主要由两部分组成:</p>
<ol>
<li>移动对象群</li>
<li>移动间隙表格</li>
</ol>
<p>可以用下面的图表示:<br>首先执行完上面代码到<code>slide_objs_and_make_bt</code>之前:<br><img src="/assets/img/gc/gc_mc_tb_1.png" alt="间隙表格"><br>执行<code>slide_objs_and_make_bt</code>后, 移动了对象群，并且在空出来的空间里记录了间隙表格, 左值100表示对象群首地址B的地址，右值100表示B之前的空白块长度为100<br><img src="/assets/img/gc/gc_mc_tb_2.png" alt="间隙表格"><br>再次执行<code>slide_objs_and_make_bt</code>后，F开头的对象群也进行了移动，并且把两个活动对象群对应的间隙表格都放到了空白块中，第二个间隙表格的550表示F的起始地址，右值300表示第一次执行<code>slide_objs_and_make_bt</code>后，第一个活动对象群的末尾到第二个活动对象群的开始，正好是6块，也就是上图<code>$free</code>到<code>live</code>的size大小是300。执行完最终结果如下:<br><img src="/assets/img/gc/gc_mc_tb_3.png" alt="间隙表格"></p>
<p>第二步更新指针的伪代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">adjust_ptr() &#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        *r = new_address(*r)</span><br><span class="line">    </span><br><span class="line">    scan = $heap_start</span><br><span class="line">    <span class="comment"># 对活动对象更新指针</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $free)</span><br><span class="line">        scan.mark = FALSE</span><br><span class="line">        <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">            *child = new_address(*child)</span><br><span class="line">        scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到活动对象对应的应该跟新到的指针地址</span></span><br><span class="line">new_address(obj) &#123;</span><br><span class="line">    best_entry = new_bt_entry(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(entry : break_table)</span><br><span class="line">        <span class="keyword">if</span>(entry.address &lt;= obj &amp;&amp; $best_entry.address &lt; entry.address)</span><br><span class="line">            best_entry = entry</span><br><span class="line">    <span class="keyword">return</span> obj - best_entry.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>new_address</code>函数比较难理解，就是需要从多个间隙表格中找到活动对象群所对应的，然后利用obj-best_entry.size 就返回节点对应的新地址。</p>
<p>优点: 首先内存利用率和Two-Finger一样，但是由于是保持了原来的顺序，所以可以利用缓存。<br>缺点: 每次移动都要进行表格的移动和更新，代价比较高。</p>
<h3 id="ImmixGC_算法">ImmixGC 算法</h3><p>暂略……</p>
<h2 id="保守式GC">保守式GC</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/gc/">gc</a>
    </span>
    

    </div>

    
  </div>
</article>

  



    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2017 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>