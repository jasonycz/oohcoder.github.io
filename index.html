<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>OohCode | 好奇的码农~</title>

  
  <meta name="author" content="sean chen">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="OohCode"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="OohCode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">OohCode</a>
    </h1>
    <p class="site-description">好奇的码农~</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2017/02/03/gc-advanced/"><span>垃圾回收进阶算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/02/03/gc-advanced/" rel="bookmark">
        <time class="entry-date published" datetime="2017-02-03T07:25:21.000Z">
          2017-02-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>了解GC的基本算法后，还需要了解各种改进的GC算法，这些算法是在之前的基础上进行扩展和组合的。主要包括<code>GC标记-压缩算法</code>, <code>保守式GC</code>, <code>分代垃圾回收</code>， <code>增量式垃圾回收</code>和<code>RC Immix算法</code>等。</p>
</blockquote>
<h2 id="1-_GC标记-压缩算法">1. GC标记-压缩算法</h2><p>GC标记-压缩算法(Mark Compact GC)是将GC标记-清除算法与GC复制算法相结合的产物。 GC标记-压缩算法由标记阶段和压缩阶段构成。标记阶段和GC标记-清除算法提到的标记阶段一样。接下来需要搜索数次的堆来进行压缩。压缩阶段通过数次搜索堆来重新装填活动对象。</p>
<h3 id="Lisp2算法">Lisp2算法</h3><p>标记阶段的代码就不重复了，这里主要看压缩阶段的代码，下面可以看出压缩阶段主要分为三个步骤:</p>
<ol>
<li>第一步是<code>set_forwarding_ptr</code>, 主要是按顺序遍历堆内的活动对象，每个活动对象的<code>forwarding</code>指针指向的是以后这个活动对象需要移动到的位置。</li>
<li>第二步是<code>adjust_ptr</code>, 遍历整个活动对象，复制他们之间的引用关系, 这个步骤只更新指针。</li>
<li>第三步<code>move_obj</code>, 遍历整个堆，对活动对象进行移动。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">compaction_phase() &#123;</span><br><span class="line">    set_forwarding_ptr()</span><br><span class="line">    adjust_ptr()</span><br><span class="line">    move_obj()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_forwarding_ptr() &#123;</span><br><span class="line">    scan = new_address = $head_start</span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end)</span><br><span class="line">        <span class="comment"># 对被标记的对象，forwarding指针指向应该移动到的位置</span></span><br><span class="line">        <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line">            scan.forwarding = new_address</span><br><span class="line">            new_address += scan.size</span><br><span class="line">        <span class="comment"># 遍历整个堆</span></span><br><span class="line">        scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">adjust_ptr() &#123;</span><br><span class="line">    <span class="comment"># 移动根指针</span></span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        *r = (*r).forwarding</span><br><span class="line">    </span><br><span class="line">    scan = $head_start</span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end)</span><br><span class="line">        <span class="comment"># 每个活动对象，原来指向子节点的指针改为指向直接点的forwarding指向的地址</span></span><br><span class="line">        <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line">            <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">                *child = (*child).forwarding</span><br><span class="line">        scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">move_obj() &#123;</span><br><span class="line">    scan = $free = $head_start</span><br><span class="line">    <span class="comment"># 遍历堆</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end) </span><br><span class="line">        <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line">            new_address = scan.forwarding</span><br><span class="line">            <span class="comment"># 移动当前对象到对象forwarding指针指向的地址</span></span><br><span class="line">            copy_data(new_address, scan, scan.size)</span><br><span class="line">            <span class="comment"># 移动完活动对象后清空指针和标记，防止再次移动</span></span><br><span class="line">            new_address.forwarding = NULL</span><br><span class="line">            new_address.mark = FALSE</span><br><span class="line">            <span class="comment"># $free最终是压缩后可分配空间的开始</span></span><br><span class="line">            $free += new_address.size</span><br><span class="line">            scan += scan.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的步骤可以用下面的图形化的例子来描述:<br>首先假设原始状态如下:<br><img src="/assets/img/gc/gc_mc_list2_1.png" alt="原始状态"><br>先对其进行标记:<br><img src="/assets/img/gc/gc_mc_list2_2.png" alt="标记后"><br>设定forwarding指针:<br><img src="/assets/img/gc/gc_mc_list2_3.png" alt="设定forwarding指针"><br>更新指针:<br><img src="/assets/img/gc/gc_mc_list2_4.png" alt="更新指针"><br>移动对象:<br><img src="/assets/img/gc/gc_mc_list2_5.png" alt="移动对象"><br>上面可以看出，整个过程只是把活动对象往一边移动，活动对象之间的顺序不变。</p>
<ul>
<li>优点: 这个算法相对其他算法而言，堆利用率高，而且所有活动对象压缩到一端，不存在碎片化，能够充分的利用堆。</li>
<li>缺点: 整个压缩过程需要3遍对堆的搜索，也就是执行该算法所花费的时间与堆大小成正比，吞吐量要劣于其他算法。</li>
</ul>
<h3 id="Two-Finger算法">Two-Finger算法</h3><p>Two-Finger算法由两个步骤构成:</p>
<ol>
<li>移动对象</li>
<li>更新指针</li>
</ol>
<p>我们知道Lisp2算法是把所有对象向右滑动，不改变活动对象的顺序，而Two-Finger算法则是真正的移动对象，把后面的活动对象移动到前面的空间。为了防止对象相互覆盖，必须要将<code>所有对象整理成大小一致</code>, 这个该算法的一个前提条件。另外Lisp2算法需要单独设置forwarding指针，但是Two-Finger算法可以利用对象的域来设定forwarding指针，不要单独占空间。<br>两个步骤对象的伪代码如下, 要说明的是<code>move_obj</code>函数有两个指针:$free, 从头往后找，找空闲的空间； live，从后往前找，找活动对象。这两个指针就是Two-Finger的名称由来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">move_obj() &#123;</span><br><span class="line">    <span class="comment">#从头开始找空闲空间</span></span><br><span class="line">    $free = $heap_start</span><br><span class="line">    <span class="comment">#从尾开始找活动对象</span></span><br><span class="line">    live = $heap_end - OBJ_SIZE</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">        <span class="comment">#free, 是活动对像就略过,继续往后找</span></span><br><span class="line">        <span class="keyword">while</span>($free.mark == TRUE)</span><br><span class="line">            $free += OBJ_SIZE</span><br><span class="line">        <span class="comment">#live, 是活动对象就略过，继续往前找</span></span><br><span class="line">        <span class="keyword">while</span>(live.mark == FALSE)</span><br><span class="line">            live -= OBJ_SIZE</span><br><span class="line">        <span class="comment"># free 指针 比 live小，证明还没有结束，否则证明查找结束了</span></span><br><span class="line">        <span class="keyword">if</span>($free &lt; live)</span><br><span class="line">            <span class="comment">#把live指向的对象复制到free地址</span></span><br><span class="line">            copy_data($free, live, OBJ_SIZE)</span><br><span class="line">            <span class="comment">#live指向的对象的forwarding指针指向新地址，为下一步更新指针做准备</span></span><br><span class="line">            live.forwarding = $free</span><br><span class="line">            <span class="comment">#移动过的对象标记位FALSE</span></span><br><span class="line">            live.mark = FALSE</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">adjust_ptr() &#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        <span class="comment">#*r&gt;=$free的条件是对于被移动过的对象执行指针更新，没有移动过的对象保持原样</span></span><br><span class="line">        <span class="keyword">if</span>(*r &gt;= $free)</span><br><span class="line">            *r = (*r).forwarding</span><br><span class="line">        </span><br><span class="line">    scan = $head_start</span><br><span class="line">    <span class="comment">#scan &lt; $free 是因为对于大于scan的节点已经失效，只对当前活动对象更新</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $free)</span><br><span class="line">        <span class="comment">#更新过的标记一下</span></span><br><span class="line">        scan.mark = FLASE</span><br><span class="line">        <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">            <span class="comment">#*child &gt;= $free 的条件是对于被移动过的对象执行指针更新，</span></span><br><span class="line">            <span class="comment"># 没有移动过的对象保持原样</span></span><br><span class="line">            <span class="keyword">if</span>(*child &gt;= $free)</span><br><span class="line">                *child = (*child).forwarding</span><br><span class="line">        scan += OBJ_SIZE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点: 不需要额外的内存存储forwarding指针，内存使用效率比Lisp2高，只搜索两次堆，吞吐量也更好.</li>
<li>缺点: 压缩后对象的顺序发生了很大变化，不利于缓存的使用。而且每个对象大小必须一致，限制比较多。</li>
</ul>
<h3 id="表格算法">表格算法</h3><p>表格算法是综合了Lisp2和Two-Finger两种算法优点的算法。其主要步骤也是有两部分:</p>
<ol>
<li>移动对象(群)以及构筑间隙表格(break table)</li>
<li>更新指针</li>
</ol>
<p>前面两个每次都是移动一个活动对象，而在表格算法种每次移动的是一个群连续的活动对象，更新指针所有的信息也不再是forwarding指针，而是是有个一个叫间隙表格的方法。间隙表是由两个值组成的，其中每个表格代表的是一个活动对象群的入口，左值代表活动对象群的首地址，右值代表活动对象群所相邻的前面的空间占分块的总大小。<br>第一步过程可以用伪代码来表示:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">movie_obj()&#123;</span><br><span class="line">    <span class="comment">#从头开始遍历</span></span><br><span class="line">    scan = $free = $heap_start</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end)</span><br><span class="line">        <span class="keyword">while</span>(scan.mark == FLASE)</span><br><span class="line">            <span class="comment"># size 记录相邻的非活动对象的大小</span></span><br><span class="line">            size += scan.size</span><br><span class="line">            scan += scan.size</span><br><span class="line">        <span class="comment"># 记录活动对象的首地址</span></span><br><span class="line">        live = scan</span><br><span class="line">        <span class="keyword">while</span>(scan.mark == TRUE)</span><br><span class="line">            scan += scan.size</span><br><span class="line">        <span class="comment"># 上面两个while后，找到了第一个连续的非活动空间和第一个连续的活动空间</span></span><br><span class="line">        <span class="comment"># 移动活动对象群，并构筑间隙表格</span></span><br><span class="line">        slide_objs_and_make_bt(scan, $free, live, size)</span><br><span class="line">        <span class="comment"># 移动后记录下一个空闲空间地址</span></span><br><span class="line">        $free += (scan -live)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>slide_objs_and_make_bt</code>函数是一个比较复杂的过程，它主要由两部分组成:</p>
<ol>
<li>移动对象群</li>
<li>移动间隙表格</li>
</ol>
<p>可以用下面的图表示:<br>首先执行完上面代码到<code>slide_objs_and_make_bt</code>之前:<br><img src="/assets/img/gc/gc_mc_tb_1.png" alt="间隙表格"><br>执行<code>slide_objs_and_make_bt</code>后, 移动了对象群，并且在空出来的空间里记录了间隙表格, 左值100表示对象群首地址B的地址，右值100表示B之前的空白块长度为100<br><img src="/assets/img/gc/gc_mc_tb_2.png" alt="间隙表格"><br>再次执行<code>slide_objs_and_make_bt</code>后，F开头的对象群也进行了移动，并且把两个活动对象群对应的间隙表格都放到了空白块中，第二个间隙表格的550表示F的起始地址，右值300表示第一次执行<code>slide_objs_and_make_bt</code>后，第一个活动对象群的末尾到第二个活动对象群的开始，正好是6块，也就是上图<code>$free</code>到<code>live</code>的size大小是300。执行完最终结果如下:<br><img src="/assets/img/gc/gc_mc_tb_3.png" alt="间隙表格"></p>
<p>第二步更新指针的伪代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">adjust_ptr() &#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        *r = new_address(*r)</span><br><span class="line">    </span><br><span class="line">    scan = $heap_start</span><br><span class="line">    <span class="comment"># 对活动对象更新指针</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $free)</span><br><span class="line">        scan.mark = FALSE</span><br><span class="line">        <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">            *child = new_address(*child)</span><br><span class="line">        scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到活动对象对应的应该跟新到的指针地址</span></span><br><span class="line">new_address(obj) &#123;</span><br><span class="line">    best_entry = new_bt_entry(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(entry : break_table)</span><br><span class="line">        <span class="keyword">if</span>(entry.address &lt;= obj &amp;&amp; $best_entry.address &lt; entry.address)</span><br><span class="line">            best_entry = entry</span><br><span class="line">    <span class="keyword">return</span> obj - best_entry.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>new_address</code>函数比较难理解，就是需要从多个间隙表格中找到活动对象群所对应的，然后利用obj-best_entry.size 就返回节点对应的新地址。</p>
<p>优点: 首先内存利用率和Two-Finger一样，但是由于是保持了原来的顺序，所以可以利用缓存。<br>缺点: 每次移动都要进行表格的移动和更新，代价比较高。</p>
<h3 id="ImmixGC_算法">ImmixGC 算法</h3><p>暂略……</p>
<h2 id="2-_保守式GC">2. 保守式GC</h2><p>前面提到过GC是根据对象的指针指向去搜寻其他对象的。另一方面，GC对非指针不进行任何操作。另外可以认为调用栈、寄存器以及全局变量空间都是根。对于上面存在一个问题就是: <strong>如何识别一个变量是否是指针?</strong> 这里所说的<strong>保守式GC</strong>就是指”不能识别指针和非指针的GC”, 而<strong>准确式GC</strong>指的就是能够正确识别指针和非指针的GC。</p>
<h3 id="保守式GC">保守式GC</h3><p>之前说的下面这些空间都是根:</p>
<ul>
<li>寄存器</li>
<li>调用栈</li>
<li>全局变量空间</li>
</ul>
<p>但是事实上他们都是不明确的根(ambiguous roots)。<br>保守式GC对检查不明确的根时，所进行的基本项目是:</p>
<ul>
<li>是不是被正确对齐的值? (32位CPU，为4的倍数；64位CPU为8的倍数; 其他情况被视为非指针)</li>
<li>是不是指着堆内? (分配了GC专用堆，对象就会被分配到堆里，指向对象的指针按道理肯定指向堆内，否则就是非指针)</li>
<li>是不是指着对象的开头?(如果把对象固定大小对齐，例如”BiBOP”法，如果对象的值不是固定大小的倍数，就是非指针)</li>
</ul>
<p>当不明确的根运行GC时，偶尔会出现非指针和堆里的对象的地址一样的情况，这时就无法识别这个值是非指针，这就是<strong>“貌似指针的非指针”(false pointer)</strong>, 保守式GC这种把”貌似指针的非指针”看成”指向对象的指针”叫做”指针的错误识别”。在采用GC标记-清除算法，这种非指针会被错误的识别为活动对象，不会被回收。这样采取的是一种保守的态度，这样处理也不会出现问题。</p>
<ul>
<li>优点: 容易编写语言处理程序</li>
<li>缺点: 识别指针和非指针需要付出成本;错误识别指针会压迫堆, 会占用堆空间;能够使用的GC算法有限，不能使用移动对象的GC算法，否则就会重新非指针，照成意想不到的BUG</li>
</ul>
<h3 id="准确式GC">准确式GC</h3><p>准确式GC是基于正确识别指针和非指针的<strong>“正确的根”(exact roots)</strong>来执行GC的。要想创建正确的根，就需要”语言处理程序的支援”, 依赖语言处理程序的实现。常见的方法这里介绍两种：</p>
<ul>
<li>打标签: 通过打标签的方法把不明确的根里的所有非指针和指针都区别开来。</li>
<li><p>不把寄存器和栈当做根: 创建一个正确的根来管理，这个正确的根在处理程序里只集合了mutator可能到达的指针，然后以它为基础执行GC。 参考Rubinius语言处理程序的实现。</p>
</li>
<li><p>优点: 相对于保守式GC，能够正确识别指针和非指针，适用的GC方法也更广泛。</p>
</li>
<li>缺点: 需要语言处理程序的支援，给实现者带来负担。</li>
</ul>
<h3 id="间接引用">间接引用</h3><p>保守式GC有一个缺点就是”不能使用GC复制算法等移动对象的算法”, 因为如果是非指针的对象发生移动，其值就会发生变化，使用这个对象就会出现问题。解决这个问题的方法就是使用”间接引用”<br>结合下图来说明:<br>复制前可以看到根和对象之间有句柄。每个对象都有一个句柄，它们分别持有指向这些对象的指针。并且局部变量和全局变量这些不明确的根里没有指向对象的指针，只装着指向句柄的指针(如图中的1，2，3), 下图中的1，2表示指针，3表示非指针。<br><img src="/assets/img/gc/gc_handle_1.png" alt="间接引用1"><br>复制之后移动了引用目标的对象，只修改了1，2是指针的值，非指针3的值并没有发生改变。<br><img src="/assets/img/gc/gc_handle_2.png" alt="间接引用2"></p>
<ul>
<li>优点: 可以适用于更多的GC算法</li>
<li>缺点: 所有对象都要经由句柄间接引用，回拉低访问对象内数据的速度。</li>
</ul>
<h3 id="MostlyCopyingGC">MostlyCopyingGC</h3><p>又是一个为了能够执行GC复制算法的保守式GC, 这个算法的核心思想就是抛开那些不能移动的对象，将其他”大部分”的对象都进行复制的GC算法，目的是为了保证不能移动的对象一定不会移动，可以移动的对象大部分都移动了，保证不出现BUG。<br>这个算法执行的前提条件:</p>
<ol>
<li>根是不明确的根</li>
<li>没有不明确的数据结构</li>
<li>对象大小随意</li>
</ol>
<p>执行这个算法的要点是把堆分配成一定大小的页(page)组成，执行分配的时候从正在使用的页里分配，如果空间不够则使用空页，如果一个页放不下，则会跨页存储。<br>执行GC时把所有根直接引用的页升级为To空间，然后再把To页对象的子对象复制到空页。这个过程会保留根直接引用的对象，所以不会复制非指针对象。同时升级的页中也包含了垃圾对象吗，无法清除。</p>
<h3 id="黑名单">黑名单</h3><p>保守式GC指针的错误识别所带来害处和这个对象的大小及其子对象的数量有关系，如果一个对象很大，或者子对象很多，却被识别为”还活着”, 那就会在占用很多的堆空间。<br>这里的黑名单记录的是”不明确的根内的非指针，其指向的是有可能被分配对象的地址”， 这里说的”有可能被分配对象的地址”指的是”堆内未使用的对象的地址”。mutator无法引用至今未使用过的对象。也就是说，如果根里存在有这种地址的指针，那它肯定就是”非指针”，就会被记入黑名单中。在分配对象过程中，如果要分配的地址在黑名单中，这个对象有可能被非指针值所引用。也就是说，及时分配后对象成了垃圾，也很有可能被错误识别为”还活着”。为此，对象分配到这种地址是要满足:</p>
<ul>
<li>小对象</li>
<li>没有子对象的对象</li>
</ul>
<p>这样及时错误识别了，对整个堆的影响也不大，把对堆的压迫控制在最低限度。</p>
<h2 id="3-_分代垃圾回收">3. 分代垃圾回收</h2><p>分代垃圾回收(Generational GC)把对象按“年龄”进行分类，使用不同的GC算法, 提高垃圾回收的效率。<strong>年龄</strong>的概念就是指对象的生存时间，经历一次GC后活下来的对象年龄就是1，依次类推。 新生成的对象和年龄小于一定值得对象都称为<strong>新生代对象</strong>, 年龄大于一定值得对象则称为<strong>老年代对象</strong>, 这就是所谓的分代。新生代对象经历一定GC后会变成老年代对象，这个过程就叫<strong>晋升(promotion)</strong>。</p>
<h4 id="Ungar_的分代垃圾回收">Ungar 的分代垃圾回收</h4><p>Ungar 的垃圾回收是针对新生代执行GC复制算法，针对老年代执行标记-清除算法。Ungar 将堆结构分为四个部分，分别是生成空间、2个大小相等的幸存空间以及老年代空间，并分别用<code>$new_start</code>、<code>$survivor1_start</code>、<code>$survivor2_start</code>、<code>$old_start</code>这4个变量引用它们的开头。将生成空间和幸存空间合称为新生代空间。<br>当生成空间满了的时候，新生代GC就会启动，将生成空间的所有活动对象复制，这根GC复制算法是一个道理。目标空间是幸存空间中空闲的一个。</p>
<pre>
      记 录 集
    +---+---+---+---+
$rs |   |   |   |   |
    +---------------+
    +------------------------+ $new_start
    |              +--------------+   $survivor1_start
    |              |     +-------------+ $survivor2_start
    |              |     |     +-----------+  $old_start
    |              |     |     |                           堆
    v--------------v-----v-----v-----------------------------+
    |              |     |     |                             |
    |              |     |     |                             |
    |              |     |     |                             |
    +--------------+-----+-----+-----------------------------+
     生 成 空 间     幸 存 空 间            老 年 代 空 间
           新 生 代 空 间
</pre>

<p>分代垃圾回收的优点是只将垃圾回收的重点放在新生代对象上，以此来缩减GC所需的时间。但是老年代有可能引用了新生代对象，所以还需要遍历老年代对象，这样就大大削减了分代垃圾回收的优势，所以为了解决这个问题，又增加了一个<strong>记录集</strong>。记录集里记录的是对新生代有引用的老年代对象。这样在新生代GC时，只需要再对记录集进行遍历就行了。<br>为了将老年代对象记录到记录集里，我们利用写入屏障(write barrier)。在mutator更新对象间的指针操作中，写入屏障是不可或缺的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">write_barrier(obj, field, new_obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj &gt;= $old_start <span class="comment">#发出引用的对象在老年代里</span></span><br><span class="line">        &amp;&amp; new_obj &lt; $old_start <span class="comment">#新生成的对象在新生代里</span></span><br><span class="line">        &amp;&amp; obj.remembered == FALSE) <span class="comment">#老年代对象没有被记录</span></span><br><span class="line">        $rs[$rs_index] = obj <span class="comment">#老年代对象加入记录集</span></span><br><span class="line">        $rs_index++ </span><br><span class="line">        obj.remembered = TRUE <span class="comment">#表示已经被记录过</span></span><br><span class="line">    *field = new_obj <span class="comment">#field是obj的指针，更新指针new_obj成为引用目标的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分配是在生成空间进行的，执行分配的<code>new_obj()</code>函数伪代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size) &#123;</span><br><span class="line">    <span class="keyword">if</span>($new_free + size &gt;= $survivor1_start)</span><br><span class="line">        <span class="comment"># 生成空间不够用，执行新生代GC</span></span><br><span class="line">        minor_gc()</span><br><span class="line">        <span class="keyword">if</span>($new_free + size &gt;= $survivor1_start)</span><br><span class="line">            <span class="comment"># 执行GC后仍然不够用，返回错误</span></span><br><span class="line">            allocation_fail()</span><br><span class="line">    </span><br><span class="line">    obj = $new_free <span class="comment">#$new_free 是指向生成空间的分块开头的指针</span></span><br><span class="line">    $new_free += size</span><br><span class="line">    obj.age = <span class="number">0</span> <span class="comment">#年龄默认值</span></span><br><span class="line">    obj.forwarded = FALSE <span class="comment">#防止重复复制相同对象的标志，跟GC复制算法和GC标记-压缩算法中的作用一样</span></span><br><span class="line">    obj.remembered = FALSE <span class="comment">#是否在记录集里，只用于老年代对象</span></span><br><span class="line">    obj.size = size</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>新生代GC的伪代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">minor_gc() &#123;</span><br><span class="line">    $to_survivor_free = $to_survivor_start</span><br><span class="line">    <span class="comment">#根在新生代的对象进行GC复制</span></span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        <span class="keyword">if</span>(*r &lt; $old_start)</span><br><span class="line">            *r = copy(*r)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="comment">#对记录集里的对象的子节点进行GC复制</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; $rs_index)</span><br><span class="line">        has_new_obj = FALSE</span><br><span class="line">        <span class="keyword">for</span>(child : children($rs[i]))</span><br><span class="line">            <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line">                *child = copy(*child)</span><br><span class="line">                <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line">                    has_new_obj = TRUE</span><br><span class="line">        <span class="comment"># TRUE表示复制后的对象在新生代，FALSE表示复制后的对象在老年代</span></span><br><span class="line">        <span class="comment"># 复制后的对象在老年代，则需要把这个对象从记录集里去掉</span></span><br><span class="line">        <span class="keyword">if</span>(has_new_obj == FALSE)</span><br><span class="line">            $rs[i].remembered = FALSE</span><br><span class="line">            $rs_index--</span><br><span class="line">            <span class="comment">#最后一位与当前节点交换，交换后，最后一位无法在访问到，可以认为是从记录集里去掉了</span></span><br><span class="line">            swap($rs[i], $rs[$rs_index])</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++</span><br><span class="line">    <span class="comment">#交换From空间和To空间</span></span><br><span class="line">    swap($from_survivor_start, $to_survivor_start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象的复制</span></span><br><span class="line">copy(obj) &#123;</span><br><span class="line">    <span class="comment">#没有被复制</span></span><br><span class="line">    <span class="keyword">if</span>(obj.forwarded == FALSE)</span><br><span class="line">        <span class="comment">#年龄没有达到</span></span><br><span class="line">        <span class="keyword">if</span>(obj.age &lt; AGE_MAX)</span><br><span class="line">            copy_data($to_survivor_free, obj, obj.size)</span><br><span class="line">            <span class="comment"># 标识已经被复制</span></span><br><span class="line">            obj.forwarded = TRUE</span><br><span class="line">            <span class="comment"># 被复制到的地址</span></span><br><span class="line">            obj.forwarding = $to_survivor_free</span><br><span class="line">            <span class="comment"># age++</span></span><br><span class="line">            $to_survivor_free.age++</span><br><span class="line">            $to_survivor_free += obj.size</span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                *child = copy(*child)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment"># 年龄达到，晋升到老年代</span></span><br><span class="line">            promote(obj)</span><br><span class="line">    <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象从新生代晋升到老年代</span></span><br><span class="line">promote(obj) &#123;</span><br><span class="line">    <span class="comment">#从老年代找空间</span></span><br><span class="line">    new_obj = allocate_in_old(obj)</span><br><span class="line">    <span class="keyword">if</span>(new_obj == NULL)</span><br><span class="line">        <span class="comment">#空间不够执行老年代的GC，跟GC标记-清除法一样</span></span><br><span class="line">        major_gc()</span><br><span class="line">        new_obj = allocate_in_old(obj)</span><br><span class="line">        <span class="keyword">if</span>(new_obj == NULL)</span><br><span class="line">            allocation_fail()</span><br><span class="line">    obj.forwarding = new_obj</span><br><span class="line">    obj.forwarded = TRUE</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(child : children(new_obj))</span><br><span class="line">        <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line">            $rs[$rs_index] = new_obj</span><br><span class="line">            $rs_index++</span><br><span class="line">            new_obj.remembered = TRUE</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分代垃圾回收是建立在”很多对象年纪轻轻就会死”的基础上的，所以满足这种条件时，可以改善GC所花费的时间，提高吞吐量。是但是因为老年代GC很费时，所以没办法缩短mutator的最大暂停时间。并且如果不满足上面的条件时，就没办法利用到分代垃圾回收的优势。</p>
<h3 id="记录各代之间的引用的方法">记录各代之间的引用的方法</h3><p>Ungar 分代垃圾回收的记录集是不可少的，但是这个记录集会浪费很多空间，为了提高内存利用率，可以通过下面两种方法：</p>
<ul>
<li>卡片标记: 把老年代空间等分成N个卡片，每份假设129字节(1024位)，可以用表格表格中位图的一位表示一个卡片，这样能够有效提高内存空间(只需老年代的1/1024)。当标记表格设置很多位时，可能就会在搜索卡片上花费大量时间。</li>
<li>页面标记: 利用OS的页面管理，如果在卡片标记中奖卡片和页面设置为同样大小，我们就能得到OS的帮助。一旦mutator对堆内的某一个页面进行写入操作，OS就会设置跟这个页面对应的位，我们把这个位叫做页面重写标志位(dirty bit)。卡片标记中是搜索标记表格，而页面标记则是搜索这个页面的重写标志位。</li>
</ul>
<h3 id="多代垃圾回收">多代垃圾回收</h3><p>分代垃圾回收是把对象分为新生代和老年代两个，也可以分成3个及更多个, 分代越多，对象变成垃圾的机会也就越大，所以这个方法确实能够减少活到最老代的对象。但是每代的空间也就相应的变小了，这样一来各代之间的引用就变多了，各代中垃圾回收花费的时间也就越来越长了。综合来看，少设置一些分代能得到更优秀的吞吐量，据说分为2代或3代是最好的。</p>
<h3 id="列车垃圾回收">列车垃圾回收</h3><p>Ungar 分代垃圾回收的一个问题是不能够减少最大暂停时间，而列车垃圾回收(Train GC)就是为了控制老年代GC中暂停时间的增长而设计的。列车垃圾回收中将老年代空间按照一定的大小划分，每个划分出来的空间称为车厢，多个车厢有组成列车，多个列车一起组成了老年代空间。1次老年代GC不再是对整个老年代空间进行，而是以1个车厢作为GC对象。<br>下面这幅图反应的是列车垃圾回收的堆结构:<br><img src="/assets/img/gc/train_gc_1.png" alt="列车垃圾回收堆结构"><br>具体过程省略……</p>
<ul>
<li>优点: 缩减了老年代GC照成的mutator的最大暂停时间。还能回收循环的大型垃圾。</li>
<li>缺点: 执行写入屏障的额外负担要比Ungar的分代垃圾回收中执行时所产生的更大，因此吞吐量上要弱一些。</li>
</ul>
<h2 id="4-_增量式垃圾回收">4. 增量式垃圾回收</h2><p>增量式垃圾回收(Incremental GC)是一种通过逐渐推进垃圾回收来控制mutator最大暂停时间的方法。之前介绍的GC算法，一旦GC开始执行，mutator就没有办法执行了，像这样的GC叫做听执行GC。为了改变这种方式，想出了一种GC和mutator交替运行的方式，这就是增量垃圾回收。</p>
<h3 id="三色标记算法">三色标记算法</h3><p>这个算法将GC中的对象按照各自情况分成三种:</p>
<ul>
<li>白色: 还未搜索过的对象</li>
<li>灰色: 正在搜索的对象</li>
<li>黑色: 搜索完成的对象</li>
</ul>
<p>以GC标记-清除算为例，应用到三色标记算法中。默认对象都是白色，GC一旦运行，所有从根能够到达的对象都会被标记，然后放到栈里。放到栈里的对象被标记成灰色，然后栈里的对象依次弹出，搜索其子对象，子对象也被标记成灰色。当其所有的子对象都被标记成灰色时，该对象就被标记成黑色。当GC结束时已经不存在灰色对象了，活动对象全部为黑色，垃圾对象则为白色。<br>增量式的GC标记-清除算法可以分为以下三个阶段:</p>
<ul>
<li>根查找阶段</li>
<li>标记阶段</li>
<li>清除阶段</li>
</ul>
<p>下面是过程的伪代码，所谓标记为灰色并不是真正的标记为灰色，而是标记位TRUE,并放到栈中；置为黑色则只是标记为TRUE; 标记位白色的就是obj.mark=FALSE</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">incremental_gc() &#123;</span><br><span class="line">    case $gc_phase</span><br><span class="line">    when GC_ROOT_SCAN</span><br><span class="line">        root_scan_phase() <span class="comment">#根查找阶段</span></span><br><span class="line">    when GC_MARK</span><br><span class="line">        incremental_mark_phase() <span class="comment">#增量标记阶段</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        incremental_sweep_phase() <span class="comment">#增量清除阶段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#根查找函数</span></span><br><span class="line">root_scan_phase() &#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        mark(*r)</span><br><span class="line">    $gc_phase = GC_MARK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mark(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line">        obj.mark = TRUE</span><br><span class="line">        push(obj, $mark_stack) <span class="comment">#灰色对象放到栈里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#增量标记</span></span><br><span class="line">incremental_mark_phase() &#123;</span><br><span class="line">    <span class="keyword">for</span>(i : <span class="number">1.</span>.MARK_MAX) <span class="comment"># MARK_MAX每次从栈中弹出对象的次数</span></span><br><span class="line">        <span class="keyword">if</span>(is_empty($mark_stack) == FALSE)</span><br><span class="line">            obj = pop($mark_stack) <span class="comment">#从栈中弹出灰色对象, 标记其子对象</span></span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                mark(*child)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">#栈为空，重新从根开始查找</span></span><br><span class="line">            <span class="keyword">for</span>(r : $roots)</span><br><span class="line">                mark(*r)</span><br><span class="line">            <span class="comment">#从根查找完继续标记</span></span><br><span class="line">            <span class="keyword">while</span>(is_empty($mark_stack) == FALSE)</span><br><span class="line">                obj = pop($mark_stack)</span><br><span class="line">                <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                    mark(*child)</span><br><span class="line">        <span class="comment">#为清除阶段做准备</span></span><br><span class="line">        $gc_phase = GC_SWEEP</span><br><span class="line">        $sweeping = $heap_start</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#写入屏障，对于新节点，需要标记为灰色</span></span><br><span class="line"><span class="comment">#如果没有这一步，标记阶段进行到一半有可能不会对新的节点进行搜索</span></span><br><span class="line">write_barrier(obj, field, newobj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(newobj.mark == FALSE)</span><br><span class="line">        newobj.mark = TRUE</span><br><span class="line">        push(newobj, $mark_stack)</span><br><span class="line"></span><br><span class="line">    *field = newobj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#清除阶段</span></span><br><span class="line">incremental_sweep_phase() &#123;</span><br><span class="line">    swept_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(swept_count &lt; SWEEP_MAX) <span class="comment">#每次清除SWEEP_MAX个对象</span></span><br><span class="line">        <span class="keyword">if</span>($sweeping &lt; $heap_end)</span><br><span class="line">            <span class="keyword">if</span>($sweeping.mark == TRUE)</span><br><span class="line">                $sweeping.mark = FALSE</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">#mark=false表示白色，放入到空闲链表中</span></span><br><span class="line">                $sweeping.next = $free_list</span><br><span class="line">                $free_list = $sweeping</span><br><span class="line">                $free_size += $sweeping.size</span><br><span class="line"></span><br><span class="line">            $sweeping += $sweeping.size</span><br><span class="line">            swept_count++</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            $gc_phase = GC_ROOT_SCAN</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#分配</span></span><br><span class="line">newobj(size) &#123;</span><br><span class="line">    <span class="comment">#$free_siz 小于一定量时就执行GC， 而不是等到空间枯竭</span></span><br><span class="line">    <span class="keyword">if</span>($free_size &lt; HEAP_SIZE * GC_THRESHOLD)</span><br><span class="line">        incremental_gc()</span><br><span class="line">    </span><br><span class="line">    chunk = pickup_chunk(size, $free_list)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        chunk.size = size</span><br><span class="line">        $free_size -= size</span><br><span class="line">        <span class="comment">#chunk如果在清除阶段在要清除的空间，需要涂黑，表示不可回收</span></span><br><span class="line">        <span class="keyword">if</span>($gc_phrase == GC_SWEEP &amp;&amp; $sweeping &lt;= chunk)</span><br><span class="line">            chunk.mark = TRUE</span><br><span class="line">            <span class="keyword">return</span> chunk</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面整个过程，分配和GC是交替进行的，而且GC的三个阶段也是按顺序循环进行的，每次执行incremental_gc()都会进入下一个阶段。</p>
<ul>
<li>优点: 增量式垃圾回收不是一口气运行GC,而是和mutator交替运行的，因此不会长时间妨碍到mutator的运行。</li>
<li>缺点: 牺牲了吞吐量。吞吐量和最大暂停时间是互相权衡的，一方面做的好另一方面就会变差。</li>
</ul>
<h3 id="Steele的算法">Steele的算法</h3><p>这个算法中使用的写入屏障要比上面(Dijkstra)的写入屏障条件更严格，它能减少GC中错误的标记的对象。<br>这个算法的标记函数如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mark(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line">        push(obj, $mark_stack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出在放入栈时并没有标记<code>obj.mark=TRUE</code>, 也就是说这个算法的<strong>灰色对象</strong>是指”堆在标记栈里的没有设置标志位的对象”, 黑色对象是”设置了标志位的对象”。<br>写入屏障的伪代码也不一样:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">write_barrier(obj, field, newobj) &#123;</span><br><span class="line">    <span class="keyword">if</span>($gc_phase == GC_MARK &amp;&amp;</span><br><span class="line">        obj.mark == TRUE &amp;&amp;</span><br><span class="line">        newobj.mark == FALSE)</span><br><span class="line">        obj.makr = FALSE</span><br><span class="line">        push(obj, $mark_stack)</span><br><span class="line"></span><br><span class="line">    *field = newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码主要是判断如果在标记过程中发出引用的对象是黑色对象，且新的引用的目标对象为灰色或白色，那么我们就把发出引用的对象涂成灰色。Steele的写入屏障通过限制标记对象来减少被标记的对象，从而防止了因疏忽而造成垃圾残留的后果。 (详情参见P175)</p>
<h3 id="汤浅的算法">汤浅的算法</h3><p>汤浅的算法中标记阶段并没有在搜索根，遵循了”以GC开始时对象间的引用关系为基础执行GC”这项原则。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">incremental_mark_phase() &#123;</span><br><span class="line">    <span class="keyword">for</span>(i : <span class="number">1.</span>.MARK_MAX)</span><br><span class="line">        <span class="keyword">if</span>(is_empty($mark_stack) == FALSE)</span><br><span class="line">            obj = pop($mark_stack)</span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                mark(*child)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        $gc_phrase = GC_SWEEP</span><br><span class="line">        $sweeping = $heap_start</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面通过写入屏障防止产生从黑色对象指向白色对象的指针，而汤浅的算法中却允许黑色对象指向白色对象的指针。汤浅算法是基于在GC开始时保留活动对象这项原则，就没有必要在生成新指针时标记引用对象的目标了。及时出现了从黑色对象指向白色对象的指针，只要保留了GC开始时的指针，作为引用目标的白色对象早晚会被标记。但是在删除指针时无法保留指针，因此写入屏障要进行一些特殊处理:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">write_barrier(obj, field, newobj) &#123;</span><br><span class="line">    oldobj = *field</span><br><span class="line">    <span class="comment">#在标记阶段中如果指针更新前引用的oldobj是白色对象，就将其涂成灰色</span></span><br><span class="line">    <span class="keyword">if</span>(gc_phase == GC_MARK &amp;&amp; oldobj.mark == FALSE)</span><br><span class="line">        oldobj.mark = TRUE</span><br><span class="line">        push(oldobj, $mark_stack)</span><br><span class="line"></span><br><span class="line">    *field = newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#分配</span></span><br><span class="line">newobj(size) &#123;</span><br><span class="line">    <span class="keyword">if</span>($free_size &lt; HEAP_SIZE  * GC_THRESHOLD)</span><br><span class="line">        incremental_gc()</span><br><span class="line"></span><br><span class="line">    chunk = pickup_chunk(size, $free_list)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        chunk.size = size</span><br><span class="line">        $free_size -= size</span><br><span class="line">        <span class="comment">#这里跟之前不一样，分配后会设置obj为黑色</span></span><br><span class="line">        <span class="keyword">if</span>($gc_phase == GC_MARK)</span><br><span class="line">            chunk.mark = TRUE</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>($gc_phase == GC_SWEEP &amp;&amp; $sweeping &lt;= chunk)</span><br><span class="line">            chunk.mark = TRUE</span><br><span class="line">        <span class="keyword">return</span> chunk</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-_RC_Immix算法">5. RC Immix算法</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/gc/">gc</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="2017/02/03/gc-advanced/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/01/23/gc-base/"><span>垃圾回收基本算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/01/23/gc-base/" rel="bookmark">
        <time class="entry-date published" datetime="2017-01-23T06:24:36.000Z">
          2017-01-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>本章介绍GC的基本算法:GC标记-清除法，引用计数法, GC复制算法。这三种我认为是GC的三个方向的基本思维。其他方法都是围绕这个些基本方法展开的。</p>
</blockquote>
<h2 id="GC标记-清除法">GC标记-清除法</h2><h3 id="基本方法">基本方法</h3><p>所谓的标记-清除法，依据其字面意思就是，先做标记，然后在清除。这个过程分为两个阶段，标记阶段就是把所有活动对象坐上标记，清除阶段就是把那些没有做标记的对象，也就是非活动对象回收的阶段。利用伪代码表示就是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mark_sweep() &#123;</span><br><span class="line">    mark_phase()</span><br><span class="line">    sweep_phase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>标记阶段: 这个阶段从<code>根</code>出发，利用深度优先遍历(不用广度优先是因为深度优先搜索比广度优先搜索更能压低内存使用量。), 对每个能到达的活动对象都做上标记(用一个位来表示)。这个阶段所花费的时间与”活动对象的总数”成正比。标记阶段伪代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mark_phase() &#123;</span><br><span class="line">    <span class="comment">#遍历根节点, 进行标记</span></span><br><span class="line">    <span class="keyword">for</span>(r: $roots)</span><br><span class="line">        mark(*r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#标记函数</span></span><br><span class="line">mark(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line">        obj.mark = TRUE</span><br><span class="line">        <span class="comment">#深度优先遍历</span></span><br><span class="line">        <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">            mark(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>清除阶段: 清除阶段主要工作是通过遍历整个堆，把未被标记的对象(非活动对象)回收再利用。回收对象就是把对象作为分块，连接到被称为”空闲链表”的单向链表。之后进行分配时遍历空闲链表就可以找到分块了。两个相邻的分块如果地址是连续的，就会对其进行<strong>合并</strong>, 合并操作可以减少碎片的发生。清除阶段的伪代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sweep_phase() &#123;</span><br><span class="line">    sweeping = $heap_start</span><br><span class="line">    <span class="comment">#遍历堆</span></span><br><span class="line">    <span class="keyword">while</span>(sweeping &lt; $head_end)</span><br><span class="line">        <span class="keyword">if</span>(sweeping.mark == TRUE)</span><br><span class="line">            sweeping.mark == FALSE</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">#放入空闲链表</span></span><br><span class="line">            <span class="keyword">if</span>(sweeping.mark == $free_list + $free_list.size)</span><br><span class="line">                <span class="comment">#合并</span></span><br><span class="line">                $free_list.size += sweeping.size</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sweeping.next = $free_list</span><br><span class="line">                $free_list = sweeping</span><br><span class="line">            sweeping += sweeping.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分配: 进行mutator申请分块时，搜索空闲链表并找到合适大小的分块，这个过程就叫做分配。找到合适的分块大小有三种策略:</p>
<ol>
<li>First-fit: 找到最初发现大于等于size的分块就立刻返回。考虑到分配所需的时间，标记清除法选择的就是这种方法。</li>
<li>Best-fit: 遍历空闲链表，找到大于等于size的最小分块返回。</li>
<li>Worst-fit: 找出最大的分块，把分块分割成size大小和剩余分块。<br>分配阶段的伪代码:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size) &#123;</span><br><span class="line">    chunk = pickup_chunk(size, $free_list)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        <span class="keyword">return</span> chunk</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="优点/缺点">优点/缺点</h3><ul>
<li>优点:<ol>
<li>实现简单</li>
<li>与保守式GC算法兼容: 保守式算法就是不知道对象是否是指针，所以移动对象会造成错误(后面会讲到), 而标记清除算法是不会移动对象的，所以是兼容的。</li>
</ol>
</li>
<li>缺点:<ol>
<li>碎片化: 由于非活动对象分布不均匀，容易照成堆内的内存空间碎片化，不利于mutator的执行。</li>
<li>分配速度: 由于分配时需要遍历空闲链表，查找速度取决于要分配的块和空闲链表的分布。后面要讲到的复制算法和标记-压缩算法由于分块是连续内存分布的，所以速度要快。</li>
<li>与写时复制技术不兼容： 因为每次GC都要修改活动对象的标记位，导致写操作的发生，从而产生复制。</li>
</ol>
</li>
</ul>
<h3 id="多个空闲链表">多个空闲链表</h3><p>为了提高<strong>分配速度</strong>，一个改进就是把分块按照大小分为多个空闲链表，这样在分配的时候就可以根据要分配的空间的大小去对应的空闲链表中寻找，大大减少了查找分块的时间。<br>下面是利用多个空闲链表的new_obj()函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line">    <span class="comment">#index 是一个要分配的字的大小</span></span><br><span class="line">    index = size / (WORD_LENGTH / BYTE_LENGTH)</span><br><span class="line">    <span class="comment">#空闲链表一共有101个，0-100都是按照字精确分配到对应的$free_list[index]中，</span></span><br><span class="line">    <span class="comment">#大于100的字都分配到$free_list[101]中</span></span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">if</span>($free_list[index] != NULL)</span><br><span class="line">            <span class="comment">#直接找到对应的空闲链表</span></span><br><span class="line">            chunk = $free_list[index]</span><br><span class="line">            $free_list[index] = $free_list[index].next</span><br><span class="line">            <span class="keyword">return</span> chunk</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">#大于100的需要遍历$free_list[101]找到合适大小的块</span></span><br><span class="line">        chunk = pickup_chunk(size, $free_list[<span class="number">101</span>])</span><br><span class="line">        <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">            <span class="keyword">return</span> chunk</span><br><span class="line"></span><br><span class="line">    allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BiBOP法">BiBOP法</h3><p>针对标记-清除算法的<strong>碎片化</strong>问题, 可以把堆先分割成大小固定的块，让每个块只能配置同样大小的对象，这就是BiBOP法。如果某个大小字的活动对象很少，其他的字活动对象很多的话，这种情况也不能提高堆的利用率，无法解决碎片化的问题。</p>
<h3 id="位图标记法">位图标记法</h3><p>上面还说道标记-清除法不能够与写时复制技术兼容是因为修改标记位会引起复制发生，为了解决这个问题，位图标记法采用只收集各个对象的标志位并表格化，不跟对象一起管理。也就是把对象和标记位进行了分离。这样做有两个好处:</p>
<ol>
<li>与写时复制技术兼容: 因为GC的时候改变了标记位也不会引起对象的复制, 而位图表格非常小，所以即使被复制也不会有什么大的影响。</li>
<li>清除操作更高效: 在遍历堆的时候不需要取消标志位，可以最后在位图表格中设置。</li>
</ol>
<h3 id="延迟清除法">延迟清除法</h3><p>延迟清除法(Lazy Sweep)是缩减因清除操作而导致的mutator最大暂停时间的方法。这个方法的伪代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line">    <span class="comment">#用延迟清除法找到对应的块</span></span><br><span class="line">    chunk = lazy_sweep(size)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        <span class="keyword">return</span> chunk</span><br><span class="line">    <span class="comment">#没有找到合适的，进行一次标记操作</span></span><br><span class="line">    mark_phase()</span><br><span class="line">    <span class="comment">#再用延迟清除法找到对应的块 </span></span><br><span class="line">    chunk = lazy_sweep(size)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        <span class="keyword">return</span> chunk</span><br><span class="line">     </span><br><span class="line">    allocation_fail()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_sweep(size)&#123;</span><br><span class="line">    <span class="keyword">while</span>($sweeping &lt; $head_end)</span><br><span class="line">        <span class="keyword">if</span>($sweeping.mark == TRUE)</span><br><span class="line">            $sweeping.mark == FALSE</span><br><span class="line">        <span class="comment">#找到和大小合适的块</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>($sweeping.size &gt; size)</span><br><span class="line">            chunk = $sweeping</span><br><span class="line">            $sweeping += $sweeping + $sweeping.size</span><br><span class="line">            <span class="keyword">return</span> chunk</span><br><span class="line">        <span class="comment">#没找到继续往下找</span></span><br><span class="line">        $sweeping += $sweeping + $sweeping.size</span><br><span class="line">    <span class="comment">#遍历完了也没找到，$sweeping置为从头开始</span></span><br><span class="line">    $sweeping = $heap_start</span><br><span class="line">    <span class="keyword">return</span> NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里跟之前不同的是$sweeping是一个全局变量，每次执行lazy_sweep的时候都会从当前$sweeping的位置往后查找。如果第一次没有找到，第二次就会从头开始查找，如果第二次也没有查到，那就是没有可以分配的块了。一般情况下第一次查找范围变小了，mutator的执行时间就短了。但是有一个问题是就是当数据分配不均，比如说后面的都是活动对象，前面的都是空的，反而会增加mutator的时间。如何改善这个问题，后面会再说到。</p>
<h2 id="引用计数法">引用计数法</h2><p>GC的目的是为了释放无法被引用的对象，自然就会想到让每个对象记录下自己被引用的个数，如果个数为0表示无法被引用，那就可以对其进行回收。这种思路就是引用计数法(Reference Counting)。</p>
<h3 id="基本方法-1">基本方法</h3><p>引用计数法最重要的就是引入了一个计数器，用来记录被引用的个数。首先先看一下引用计数法的伪代码实现:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成新对象</span></span><br><span class="line">new_obj(size)&#123;</span><br><span class="line">    <span class="comment">#从空闲链表中找到合适的块</span></span><br><span class="line">    obj = pickup_chunk(size, $free_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj == NULL)</span><br><span class="line">        allocation_fail()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">#对象有一个计数器，成功生成后计数器值是1</span></span><br><span class="line">        obj.ref_cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#更新ptr指针，使其指向新对象obj</span></span><br><span class="line">update_ptr(ptr, obj)&#123;</span><br><span class="line">    <span class="comment">#被指向的对象计数器+1</span></span><br><span class="line">    inc_ref_cnt(obj)</span><br><span class="line">    <span class="comment">#原来指向的对象计数器-1</span></span><br><span class="line">    dec_ref_cnt(*ptr)</span><br><span class="line">    <span class="comment">#指向新对象</span></span><br><span class="line">    *ptr = obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#计数器+1</span></span><br><span class="line">inc_ref_cnt(obj)&#123;</span><br><span class="line">    obj.ref_cnt++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#计数器-1</span></span><br><span class="line">dec_ref_cnt(obj)&#123;</span><br><span class="line">    <span class="comment">#obj计数器-1</span></span><br><span class="line">    obj.ref_cnt--</span><br><span class="line">    <span class="comment">#obj计数器为0，说明对象变成了"垃圾", 需要对其子对象计数器都-1， 因为这个对象不存在了。</span></span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">            dec_ref_cnt(*child)</span><br><span class="line">        <span class="comment">#将obj连接到空闲链表中</span></span><br><span class="line">        reclaim(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面需要注意的一点是执行<code>update_ptr</code>的时候先执行了<code>inc_ref_cnt</code>后执行了<code>dec_ref_cnt</code>, 这是因为当<code>update_ptr</code>的前后两个对象是同一个时，如果先指向了<code>dec_ref_cnt</code>就会把这个对象删除，再执行<code>inc_ref_cnt</code>时就会出错，而顺序反过来就不会存在这个问题了。还有一点是引用计数法和标记清除法不一样的地方:引用计数法会在指针变动时发现是否是垃圾，从而立即回收，而标记清除法则即使发现了也不会立即回收，而是标记完后一起回收。</p>
<h3 id="优点/缺点-1">优点/缺点</h3><ul>
<li><p>优点</p>
<ol>
<li>可以即刻进行垃圾回收</li>
<li>最大暂停时间短: 只在发生引用关系变化时立即回收。</li>
<li>没有必要沿指针查找: 根据每个变量的引用计数来回收，不需要进行遍历。</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>计数器值的增减处理繁重</li>
<li>计数器需要占用很多位: 计数器需要记录被引用的个数，这个记录位会占用不少的内存空间。</li>
<li>实现繁琐复杂</li>
<li>循环引用无法回收:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    string name</span><br><span class="line">    Person lover</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taro = <span class="keyword">new</span> Person(<span class="string">"太郎"</span>) <span class="comment">//执行后taro的引用计数为1</span></span><br><span class="line">hanako = <span class="keyword">new</span> Person(<span class="string">"花子"</span>) <span class="comment">//执行后hanako的引用计数为1</span></span><br><span class="line">taro.lover = hanako <span class="comment">//执行后hanako的引用计数为2</span></span><br><span class="line">hanako.lover = taro <span class="comment">//执行后taro的引用计数为2</span></span><br><span class="line">taro = <span class="keyword">null</span> <span class="comment">//taro指向null, hanako引用计数-1，变为1</span></span><br><span class="line">hanako = <span class="keyword">null</span> <span class="comment">//hanako指向null, taro引用计数-1， 变为1</span></span><br><span class="line"><span class="comment">//全部执行完后taro与hanako的引用计数都为1，不能被回收，但是又无法被引用, 照成了内存泄露的情况</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>用图来说请其中的过程如下：<br><img src="/assets/img/gc/rc_cr.png" alt="循环引用图解"></p>
<h3 id="延迟引用计数法">延迟引用计数法</h3><p>上面说到引用计数法的计数器值得<strong>增减处理很繁重</strong>，为了改善这个缺点，引入了延迟引用计数法(Deferred Reference Counting)。延迟引用计数法利用ZCT(Zero Count Table)来记录计时器值在dec_ref_cnt()作用下变为0的对象, zct表内的值是指向这些对象的指针。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#update_ptr($ptr, obj)调用不变，只是dec_ref_cnt不会递每次都递归处理子节点的引用计数</span></span><br><span class="line">dec_ref_cnt(obj)&#123;</span><br><span class="line">    obj.ref_cnt--</span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">#$zct满了就执行一次扫描</span></span><br><span class="line">        <span class="keyword">if</span>(is_full($zct) == TRUE)</span><br><span class="line">            scan_zct()</span><br><span class="line">        push($zct, obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_obj(size)&#123;</span><br><span class="line">    obj = pickup_chunk(size, $free_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj == NULL)</span><br><span class="line">        <span class="comment">#空间不够执行一次扫描, 释放空间</span></span><br><span class="line">        scan_zct()</span><br><span class="line">        obj = pickup_chunk(size, $free_list)</span><br><span class="line">        <span class="keyword">if</span>(obj == NULL)</span><br><span class="line">            allocation_fail()</span><br><span class="line"></span><br><span class="line">    obj.ref_cnt = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#扫描zct</span></span><br><span class="line">scan_zct()&#123;</span><br><span class="line">    <span class="comment">#对根直接引用的对象都进行增量， 把根引用反映到计数器的值上</span></span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        (*r).ref_cnt++</span><br><span class="line">    <span class="comment">#对子对象的计数器进行减量操作，回收 </span></span><br><span class="line">    <span class="keyword">for</span>(obj : $zct)</span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line">            remove($zct, obj)</span><br><span class="line">            delete(obj)</span><br><span class="line">    <span class="comment">#恢复根节点直接引用的对象计数器的值</span></span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        (*r).ref_cnt--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#减量操作和回收</span></span><br><span class="line">delete(obj)&#123;</span><br><span class="line">    <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">        (*child).ref_cnt--</span><br><span class="line">        <span class="keyword">if</span>((*child).ref_cnt == <span class="number">0</span>)</span><br><span class="line">            delete(*child)</span><br><span class="line"></span><br><span class="line">    reclaim(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>书举例说<code>update_ptr($ptr, obj)</code>改写成<code>*$ptr = obj</code>, 我理解这只是举了一个例子说明不需要增减计数器。实际后面的代码中可以看出，还是使用的<code>update_ptr($ptr, obj)</code>,否则就没有对<code>dec_ref_cnt(obj)</code>的调用了。变化比较大的是<code>dec_ref_cnt(obj</code>函数，它不再递归调用子节点的计数器减量，而是直接把它放到zct结构中，在必要时调用scan_zct, 这就大大减少了计数器值得增减。</p>
<ul>
<li>优点: 延迟了根引用的技术，将垃圾一并回收，减轻了因根引用频发发生的变化导致计数器增减所带来的额外负担。</li>
<li>缺点: 失去了引用计数法的一大优点–可即可回收垃圾。另外scan_zct()导致最大暂停时间延长了。</li>
</ul>
<h3 id="Sticky引用计数法">Sticky引用计数法</h3><p>引用计数法有一个问题就是计数器要设置多大的位宽。如果设置的小了，有可能会出现存不下而溢出的情况；如果设置的大了，又会占用过多的空间。Sticky的思想就是设置一个固定大小的位数，这个位数要比较小，对于溢出的情况下面两种处理方式:</p>
<ul>
<li>什么都不做<br>当计数器出现溢出时，不对其进行任何操作，其值就是能存储的最大值，一般情况下这个值很难达到，如果达到了这个值，证明其非常重要，其成为垃圾的可能性也非常小，对其计数不增也不减，不会存在什么大的问题。</li>
<li>使用GC标记-清除算法进行管理<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mark_sweep_for_counter_overflow()&#123;</span><br><span class="line">    <span class="comment">#所有计数器清零</span></span><br><span class="line">    reset_all_ref_cnt()</span><br><span class="line">    mark_phase()</span><br><span class="line">    sweep_phase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#对所有可以达到的节点进行标记，每个节点及其子节点只会进栈一次，所以引用计数的值最多为2， 不会出现溢出的情况</span></span><br><span class="line">mark_phase()&#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        <span class="comment">#所有根节点放到标记栈中</span></span><br><span class="line">        push(*r, $mark_stack)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(is_empty($mark_stack) == FALSE)</span><br><span class="line">        obj = pop($mark_stack)</span><br><span class="line">        <span class="comment">#弹出栈，引用计数+1</span></span><br><span class="line">        obj.ref_cnt++</span><br><span class="line">        <span class="comment">#只有引用计数为1才让其子节点进栈，已经进过的不会再进</span></span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                push(*child, $mark_stack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#清除节点遍历堆，所有标记位为0的节点进行回收</span></span><br><span class="line">sweep_phase()&#123;</span><br><span class="line">    sweeping = $heap_top</span><br><span class="line">    <span class="keyword">while</span>(sweeping &lt; $head_end)</span><br><span class="line">        <span class="keyword">if</span>(sweeping.ref_cnt == <span class="number">0</span>)</span><br><span class="line">            reclaim(sweeping)</span><br><span class="line">        sweeping += sweeping.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这么做可以在溢出后依然回收，而且没有对循环引用页适用，但是需要重置计数器。查找对象时没有设置标记位，而只是增量计数器，会出现多次查找活动对象的问题。比起一般的GC标记-清除算法需要更多的时间，吞吐量也会变小。</p>
<h3 id="1位引用计数法">1位引用计数法</h3><p>1位引用计数法(1 bit Reference Counting)是Sticky引用计数法的极端例子，计数器只有1位大小。这里的计数器不在表示引用的个数，而是表示有一个引用还是多个引用。</p>
<ol>
<li>当计数器值为0，表示对象引用数为1，这种状态称为<strong>UNIQUE</strong></li>
<li>当计数器值为1， 表示引用数为复数, 这种状态称为<strong>MULTIPLE</strong></li>
</ol>
<p>相关伪代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指针复制 </span></span><br><span class="line"><span class="comment">#dest_ptr: 目的指针 </span></span><br><span class="line"><span class="comment">#src_ptr: 源指针 </span></span><br><span class="line">copy_ptr(dest_ptr, src_ptr)&#123;</span><br><span class="line">    <span class="comment">#由于目的指针原来指向的内容不再指向，需要对目的指针指向删除操作 </span></span><br><span class="line">    delete_ptr(dest_ptr)</span><br><span class="line">    <span class="comment">#执行复制 </span></span><br><span class="line">    *dest_ptr = *src_ptr</span><br><span class="line">    <span class="comment">#目的指针由于和源指针指向了同一个对象，目的指针需要设置为MULTIPLE </span></span><br><span class="line">    set_multiple_tag(dest_ptr)</span><br><span class="line">    <span class="comment">#源指针如果原来是UNIQUE, 现在多了一个目的指针，需要设置为MULTIPLE </span></span><br><span class="line">    <span class="keyword">if</span>(tag(src_ptr) == UNIQUE)</span><br><span class="line">        set_multiple_tag(src_ptr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除目的指针原来的指向对象 </span></span><br><span class="line">delete_ptr(ptr)&#123;</span><br><span class="line">    <span class="comment">#如果原来是UNIQUE，说明对象只有一个指针，删除后需要回收 </span></span><br><span class="line">    <span class="keyword">if</span>(tag(ptr) == UNIQUE)</span><br><span class="line">        <span class="comment">#回收 </span></span><br><span class="line">        reclaim(ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其过程可以参考下图:<br><img src="/assets/img/gc/1bit_rc.png" alt="1bit_rc"></p>
<ul>
<li>优点: <ol>
<li>不容易出现高速缓存缺失， 如上图所示，在更新计数器的时候不需要读取元素的值到内存中（C,D完全没有读), 只需要更新指针的计数器，所以不会出现内存中离得远找出缓存缺失。</li>
<li>计数器所占空间很小，节省内存。</li>
</ol>
</li>
<li>缺点: 1位引用计数器是在大量计数器都不足2的前提下来做的，当出现大量大于2的计数器时，1位引用计数器方法就无法回收这些对象，给堆带来巨大负担。</li>
</ul>
<h3 id="部分标记-清除算法">部分标记-清除算法</h3><p>部分标记清除法主要是针对之前的无法回收循环引用的缺点而产生的。之前讲的<strong>延迟引用计数法</strong>可以处理循环引用的情况，但是效率太低。部分-标记清除算法只针对有可能是循环引用的对象上执行，在一般的对象上还是执行引用计数法。下面结合代码图图示说明一下部分标记-清除算法的过程。</p>
<p>部分标记-清除算法中，对象被涂成四种颜色来管理。每个颜色的含义如下：</p>
<ol>
<li>黑(BLACK): 绝对不是垃圾的对象(对象产生时的初始颜色)</li>
<li>白(WHITE): 绝对是垃圾的对象</li>
<li>灰(GRAY): 搜索完毕的对象</li>
<li>阴影(HATCH): 可能是循环垃圾的对象</li>
</ol>
<p>首先我们假设有一个循环引用对象群，<strong>初始状态</strong>如下：<br><img src="/assets/img/gc/pms_rc_1.png" alt="初始状态"><br>图中A和D是由根引用。所有对象在初始状态下都为黑色。<br>对应的初始代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line">    obj = pickup_chunk(size)</span><br><span class="line">    <span class="keyword">if</span>(obj != NULL)</span><br><span class="line">        <span class="comment">#初始颜色会BLACK</span></span><br><span class="line">        obj.color = BLACK</span><br><span class="line">        obj.ref_cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(is_empty($hatch_queue) == FALSE)</span><br><span class="line">        <span class="comment">#当空间不够用时扫描可能是循环引用的对象，然后释放出新的空间, 再次调用new_obj</span></span><br><span class="line">        scan_hatch_queue()</span><br><span class="line">        <span class="keyword">return</span> new_obj(size)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当执行<code>dec_ref_cnt()</code>时, 引用计数为0， 则回收。不为0时都认为是<strong>可能存在循环引用</strong>的对象, 都标记成HATCH, 并且把这个对象放到<code>$hatch_queue</code>当中。代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dec_ref_cnt(obj)&#123;</span><br><span class="line">    obj.ref_cnt--</span><br><span class="line">    <span class="comment">#ref_cnt == 0, 回收对象</span></span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line">        delete(obj)</span><br><span class="line">    <span class="comment">#ref_cnt != 0 认为是可能存在循环引用的对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(obj.color != HATCH)</span><br><span class="line">        obj.color = HATCH</span><br><span class="line">    enqueue(obj, $hatch_queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>针对上面的图，如果A的引用被删除了，则执行<code>dec_ref_cnt()</code>之后的状态如下图:</p>
<p><img src="/assets/img/gc/pms_rc_2.png" alt="执行dec_ref_cnt"></p>
<p>这是对象群在调用<code>new_obj()</code>时已经没有心的内存空间可以使用，所以会触发<code>scan_hatch_queue()</code>函数的调用。对应代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">scan_hatch_queue()&#123;</span><br><span class="line">    <span class="comment">#可能是循环引用的对象出队列</span></span><br><span class="line">    obj = dequeue($hatch_queue)</span><br><span class="line">    <span class="comment">#如果颜色为HATCH, 依次调用下面的函数</span></span><br><span class="line">    <span class="keyword">if</span>(obj.color == HATCH)</span><br><span class="line">        paint_gray(obj)</span><br><span class="line">        scan_gray(obj)</span><br><span class="line">        collect_white(obj)</span><br><span class="line">    <span class="comment">##如果颜色不为HATCH, 证明不是循环引用对象，继续下一个元素</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(is_empty($hatch_queue) == FALSE)</span><br><span class="line">        scan_hatch_queue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面需要调用的<code>paint_gray(obj)</code>函数主要作用是深度遍历对象，搜索过的对象标记位GRAY:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">paint_gray()&#123;</span><br><span class="line">    <span class="comment">#对原来是BLACK或HATCH的对象标记为GRAY</span></span><br><span class="line">    <span class="keyword">if</span>(obj.color == (BLACK | HATCH))</span><br><span class="line">        obj.color = GRAY</span><br><span class="line">    <span class="comment">#深度遍历子节点，引用计数减量, 递归调用paint_gray记性标记</span></span><br><span class="line">    <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">        (*child).ref_cnt--</span><br><span class="line">        paint_gray(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完上面的函数后，对象的状态如下图:<br><img src="/assets/img/gc/pms_rc_3.png" alt="执行dec_ref_cnt"><br>下面<code>scan_gray(obj)</code>的目的是扫描刚才的GRAY节点，把其中的垃圾对象找出来，标记成WHITE:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scan_gray(obj)&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.color == GRAY)</span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">#ref_cnt&gt;0, 不是垃圾，需要标记成BLACK</span></span><br><span class="line">            paint_black(obj)</span><br><span class="line">            <span class="comment">#ref_cnt == 0, 是垃圾对象，标记成WHITE</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            obj.color = WHITE</span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                scan_gray(*child)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">paint_black(obj)&#123;</span><br><span class="line">    obj.color = BLACK</span><br><span class="line">    <span class="keyword">for</span>(child : chidren(obj))</span><br><span class="line">        <span class="comment">#由于执行paint_gray的时候ref_cnt--, 这里要恢复ref_cnt</span></span><br><span class="line">        (*child).ref_cnt++</span><br><span class="line">        <span class="keyword">if</span>((*child).color != BLACK)</span><br><span class="line">            paint_black(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标记后的对象如下:<br><img src="/assets/img/gc/pms_rc_4.png" alt="执行dec_ref_cnt"><br>到上面的步骤后，可以看出已经知道那些颜色为WHITE的对象就是垃圾对象，这些对象需要回收，回收代码入下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">collect_white()&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.color == WHITE)</span><br><span class="line">        obj.color = BLACK</span><br><span class="line">        <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">            collect_white(*child)</span><br><span class="line">        reclaim(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回收后的图如下:<br><img src="/assets/img/gc/pms_rc_5.png" alt="执行dec_ref_cnt"><br>上面就是部分标记-清除算法的过程。这个算法的优点就是，只搜索可能是循环垃圾的对象群，就是阴影部分，如何确定这个范围呢？首先产生垃圾循环的条件有两个:</p>
<ol>
<li>产生循环引用。</li>
<li>删除从外部到循环引用的引用。</li>
</ol>
<p>部分标记-清除算法就利用<code>dec_ref_cnt()</code>函数来判断，如果引用计数减值后不为0， 那这个对象有可能就是循环对象的一份子。<br>这个算法的缺点就是需要三次查找对象，而每次查找的数量不少，所以付出的成本比较大。</p>
<h2 id="GC复制算法">GC复制算法</h2><p>GC复制算法把原来的内存空间分为两部分(From空间和To空间), 当From空间不够分配时，就会执行GC复制算法，把From空间的活动对象复制到To空间，复制完成后交换From和To空间，GC结束，分配时去心的From空间查找。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">copying()&#123;</span><br><span class="line">    <span class="comment">#$to_start To空间的起始地址</span></span><br><span class="line">    <span class="comment">#$free 要copy到的起始地址</span></span><br><span class="line">    $free = $to_start</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        *r = copy(*r)</span><br><span class="line">    <span class="comment">#交换From 和 To 空间</span></span><br><span class="line">    swap($from_start, $to_start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行From 到 To 的 copy</span></span><br><span class="line">copy(obj)&#123;</span><br><span class="line">    <span class="comment"># 如果obj.tag != COPIED, 此对象还没有被执行过COPY, 对其执行COPY</span></span><br><span class="line">    <span class="keyword">if</span>(obj.tag != COPIED)</span><br><span class="line">        copy_data($free, obj, obj.size)</span><br><span class="line">        <span class="comment">#执行完后改变tag值，下次不再对其执行COPY</span></span><br><span class="line">        obj.tag = COPIED</span><br><span class="line">        <span class="comment">#forwarding是原来对象指向复制后的对象的指针，便于新老节点对应起来，下面递归查询的时候好查找</span></span><br><span class="line">        obj.forwarding = $free</span><br><span class="line">        <span class="comment">#free是要复制到的起始地址，当复制完一个对象后，需要前进size, 到达新的地址(To空间空闲的起始地址)</span></span><br><span class="line">        $free += obj.size</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#对执行过的对象执行深度遍历，全部活动子节点都COPY到TO空间</span></span><br><span class="line">        <span class="keyword">for</span>(child : children(obj.forwarding))</span><br><span class="line">            *child = copy(*child)</span><br><span class="line">    <span class="comment">#注意，当对根节点的元素执行时，返回的是根节点执行的obj.forwarding, </span></span><br><span class="line">    <span class="comment">#所以全部执行完后，根节点结合就是原来的根节点集合的forwarding指针指向的元素</span></span><br><span class="line">    <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">new_obj()&#123;</span><br><span class="line">    <span class="comment">#这里FROM和TO等分，如果空间不够，执行GC</span></span><br><span class="line">    <span class="keyword">if</span>($free + size &gt; $from_start + HEAP_SIZE/<span class="number">2</span>)</span><br><span class="line">        copying()</span><br><span class="line">        <span class="comment">#执行完GC后空间还不够，返回失败</span></span><br><span class="line">        <span class="keyword">if</span>($free + size &gt; $from_start + HEAM_SIZE/<span class="number">2</span>)</span><br><span class="line">            allocation_fail()</span><br><span class="line"></span><br><span class="line">    obj = $free</span><br><span class="line">    obj.size = size</span><br><span class="line">    $free += size</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GC复制算法过程参考下面的图:<br><img src="/assets/img/gc/copy_1.png" alt="GC复制算法"><br><img src="/assets/img/gc/copy_2.png" alt="GC复制算法"><br><img src="/assets/img/gc/copy_3.png" alt="GC复制算法"><br><img src="/assets/img/gc/copy_4.png" alt="GC复制算法"></p>
<ul>
<li>优点:</li>
</ul>
<ol>
<li>优秀的吞吐量: 只需要搜索活动对象，不需要其他的搜索。</li>
<li>可实现高速分配: 不需要空闲链表，只移动$free指针，快速分配。</li>
<li>不会发生碎片化: 因为分配的都是连续的，GC之后也是连续的，对象都放在了堆的一端(叫做压缩)。</li>
<li>与缓存兼容: 深度优先遍历，关联的节点都被放到了相邻的位置。</li>
</ol>
<ul>
<li>缺点:</li>
</ul>
<ol>
<li>堆使用效率低下: GC复制算法通常把堆分为二等分，只有一半可以来安排对象。</li>
<li>不兼容保守式GC算法: 会发生对象的移动。</li>
<li>递归调动函数: 递归复制，每次调用都会消耗栈，会有栈溢出的可能。</li>
</ol>
<h3 id="Cheney的GC复制算法">Cheney的GC复制算法</h3><p>上面提到GC复制算法用递归复制，会有栈溢出的可能。Cheney的GC复制算法则采用广度优先的方式，用循环代替递归，解决栈溢出的问题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">copying()&#123;</span><br><span class="line">    scan = $free = $to_start</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        *r = copy(r)</span><br><span class="line">    <span class="comment">#广度优先遍历需要一个队列保，scan 到 $free 就是这个隐藏的队列</span></span><br><span class="line">    <span class="keyword">while</span>(scan != $free)</span><br><span class="line">        <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">            *child = copy(*child)</span><br><span class="line">        scan += scan.size</span><br><span class="line">        </span><br><span class="line">    swap($from_start, $to_start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy()&#123;</span><br><span class="line">    <span class="comment">#如果obj.forwarding是指向To空间指针则返回TRUE, 如果不是则返回FALSE</span></span><br><span class="line">    <span class="keyword">if</span>(is_pointer_to_heap(obj.forwarding, $to_start) == FALSE)</span><br><span class="line">        copy_data($free, obj, obj.size)</span><br><span class="line">        obj.forwarding = $free</span><br><span class="line">        $free += obj.size</span><br><span class="line">    <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/assets/img/gc/gc_copy_cheney_1.png" alt="Cheney复制算法"><br><img src="/assets/img/gc/gc_copy_cheney_2.png" alt="Cheney复制算法"><br><img src="/assets/img/gc/gc_copy_cheney_3.png" alt="Cheney复制算法"><br><img src="/assets/img/gc/gc_copy_cheney_4.png" alt="Cheney复制算法"></p>
<p>这个算法的缺点是不能利用局部缓存，因为有关系的节点不是相邻的。</p>
<h3 id="近似深度优先搜索方法">近似深度优先搜索方法</h3><p>为了解决Cheney算法不能利用局部缓存，这里进行了一个改进，对于每个“页面”内部都是广度优先搜索。下面通过一个例子，看一下Cheney与近似深度优先搜索的方法对比:<br>图1，原始的引用关系:<br><img src="/assets/img/gc/gc_cp_df_1.png" alt="近似深度优先搜索方法"><br>图2，假设每三个节点占用一个”页面”的空间，下面就是Cheney方法，广度优先遍历后的ji结果:<br><img src="/assets/img/gc/gc_cp_df_2.png" alt="近似深度优先搜索方法"><br>可以看出，上图中相互引用的节点之间存储的比较分散，不容里利用局部缓存。<br>图3是利用近似深度优先搜索方法后的结果，可以看出分布比较集中，可以很好利用局部缓存。<br><img src="/assets/img/gc/gc_cp_df_3.png" alt="近似深度优先搜索方法"></p>
<h3 id="多空间复制算法">多空间复制算法</h3><p>上面降到复制算法的一个明显的特征就是堆的利用率低。为了改善这个问题，多空间复制的算法的思想就是把一个堆N等分，只对其中2块空间执行GC复制算法，对剩下的(N-2)块空间执行GC标记-清除算法，也就是把这两种算法组合起来使用。具体细节不再展开。这个方法的优点是可以更有效的利用堆，但是缺点也很明显，就是标记-清除算法的缺点:分配耗费时间，分块碎片化等。</p>
<h2 id="总结">总结</h2><p>基本算法是进行GC的基本思想，每个算法都有其缺点和优点，没有算法能够完美解决所有问题。所以后面的算法利用这几种基本算法的组合和变形，更好的提高GC的性能。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/gc/">gc</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="2017/01/23/gc-base/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/01/22/gc/"><span>垃圾回收算法总结</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/01/22/gc/" rel="bookmark">
        <time class="entry-date published" datetime="2017-01-22T06:56:28.000Z">
          2017-01-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>最近研读了《垃圾回收的算法与实现》这本书， 对来垃圾回收(<code>GC</code>)的来龙去脉及理论和实践有了一个概括性，深入性的了解，这里分多篇进行总结。首先本文先对GC的理论来一个总览性的回顾.</p>
</blockquote>
<h2 id="什么是垃圾回收">什么是垃圾回收</h2><p>我们知道一台服务器的内存是有限的，而程序的运行需要占用内存空间，一个程序内部可能有些内存空间使用后不再使用，这部分不再使用的内从空间就被视为<code>垃圾</code>。而GC就是要</p>
<ol>
<li>找到内存空间里的垃圾</li>
<li>回收垃圾，让程序员能够再次利用这部分空间</li>
</ol>
<p>如果没有GC的情况下需要程序员自己手动管理内存，例如C/C++等程序。这个过程将会非常麻烦，如果管理不当就会照成内存泄露引起系统崩溃，引发各种恶性bug和安全问题。有了GC就会省去很大一部分精力，降低了开发的难度。</p>
<h2 id="垃圾回收基本概念">垃圾回收基本概念</h2><p>要深入了解垃圾回收的理论知识，下面这些关键件信息比必要掌握:</p>
<ul>
<li>对象/头/域: 这里对象是由头(heder)和域(field)构成的。头是指保持对象本身信息的部分，主要包括<strong>对象的大小</strong>和<strong>对象的种类</strong>;域是对象使用者可以访问的部分，域的数据类型主要分为指针和非指针两种。</li>
<li>指针: GC根据对象的指针指向去搜寻其他对象，对于非指针不进行任何操作。</li>
<li>mutator: 程序运行过程中关系的改变，主要包括<strong>生成对象</strong>和<strong>更新指针</strong>等操作。</li>
<li>堆: 用于动态存放对象的内存空间。当mutator申请存放对象时，所需的内从空间就是从这个堆中被分配给mutator的。</li>
<li>活动对象/非活动对象: 内存空间中可以通过mutator引用的对象是”活动对象”, 不能通过程序引用的称为”非活动对象”。非活动对象无法重新被引用，所以就是”垃圾”。</li>
<li>分配: 内存空间中分配(allocatio)对象。当mutator需要新对象时，就会向分配器(allocator)申请一个大小合适的空间。</li>
<li>分块: 未利用对象而事先准备的空间。初始状态堆就是一个大分块，根据mutator的需求而分割成合适的大小。</li>
<li>根: 跟是指向对象的指针的起点，通过mutator可以直接调用的调用栈(call stack),寄存器和全局变量都是根。但是调用栈和寄存器中的值是不是指针，需要再做判断。</li>
<li>评价标准: GC算法的性能评价标准主要有<ol>
<li>吞吐量: 单位时间内的处理能力。</li>
<li>最大暂停时间: 因执行GC和停止mutator的最长时间。</li>
<li>堆使用效率</li>
<li>访问的局部性: 局部性原理，数据离得越近越好处理。</li>
</ol>
</li>
</ul>
<h2 id="垃圾回收算法总览">垃圾回收算法总览</h2><p>首先先上一张垃圾回收算法的总概括图:<br><img src="/assets/img/gc/GC.png" alt="垃圾回收算法总览"><br>上面列举和好多算法及对应的细节。其实GC最基本的思想就是三种算法(GC标记-清除法, 引用计数法, GC复制算法), 其他算法都算是这几个算法的延伸和组合。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/gc/">gc</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="2017/01/22/gc/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/08/23/phpenv-configuration-options/"><span>phpenv安装自定义配置</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/08/23/phpenv-configuration-options/" rel="bookmark">
        <time class="entry-date published" datetime="2016-08-23T08:45:47.000Z">
          2016-08-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="自定义配置">自定义配置</h2><p>在使用phpenv安装php是，有时候需要对内置扩展进行自定义控制是否开启，比如我要开启<code>zts</code>模块, 源码安装我么可以用<code>./configure --enable-maintainer-zts</code>来安装，但是phpenv不支持直接这么写，这时候就要phpenv自己的方式来安装了。可以在phpenv安装的路径里找到下面这个文件：<code>~/.phpenv/plugins/php-build/bin/php-build</code>, 这个文件就是phpenv install时运行的脚本，可以找到如下内容:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">CONFIGURE_OPTIONS=$(cat <span class="string">"$PHP_BUILD_ROOT/share/php-build/default_configure_options"</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"$PHP_BUILD_CONFIGURE_OPTS"</span> ]; then</span><br><span class="line">    CONFIGURE_OPTIONS=<span class="string">"$CONFIGURE_OPTIONS $PHP_BUILD_CONFIGURE_OPTS"</span></span><br><span class="line">fi</span><br><span class="line">...</span><br><span class="line">local append_default_libdir=<span class="string">'yes'</span></span><br><span class="line"><span class="keyword">for</span> option in <span class="variable">$CONFIGURE_OPTIONS</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"$option"</span> in</span><br><span class="line">    <span class="string">"--with-libdir"</span>*) append_default_libdir=<span class="string">'no'</span> ;;</span><br><span class="line">  esac</span><br><span class="line">done</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$(uname -p)"</span> = <span class="string">"x86_64"</span> ] &amp;&amp; [ <span class="string">"$&#123;append_default_libdir&#125;"</span> = <span class="string">'yes'</span> ]; then</span><br><span class="line">    argv=<span class="string">"$argv --with-libdir=lib64"</span></span><br><span class="line">fi</span><br><span class="line">...</span><br><span class="line">./configure <span class="variable">$argv</span> &gt; /dev/<span class="keyword">null</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>可见，默认会读取<code>~/.phpenv/plugins/php-build/share/php-build/default_configure_options</code>里面的配置加到<code>./configure</code>的参数里，当存在变量<code>$PHP_BUILD_CONFIGURE_OPTS</code>时，会把这个变量的值也加到<code>./configure</code>的参数里。<br>所以就存在两种方式实现上面的安装方法：</p>
<ol>
<li><code>~/.phpenv/plugins/php-build/share/php-build/default_configure_options</code>文件末尾加上<code>--enable-maintainer-zts</code></li>
<li>运行<code>PHP_BUILD_CONFIGURE_OPTS=--enable-maintainer-zts phpenv install 5.6.2</code></li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/php/">php</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="2016/08/23/phpenv-configuration-options/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/10/14/InnoDB-Key-Features/"><span>InnoDB关键特性</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/10/14/InnoDB-Key-Features/" rel="bookmark">
        <time class="entry-date published" datetime="2015-10-14T14:10:14.000Z">
          2015-10-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>本篇博客是《Mysql技术内幕 InnoDB存储引擎(第二版)》的阅读总结.</p>
</blockquote>
<h2 id="工作方式">工作方式</h2><p>首先Mysql进程模型是单进程多线程的。所以我们通过ps查找mysqld进程是只有一个。</p>
<h3 id="体系架构">体系架构</h3><p>InnoDB存储引擎的架构如下图所以，是由多个内存块组成的内存池，同时又多个后台线程进行工作，文件是存储磁盘上的数据。</p>
<img src="http://www.plantuml.com/plantuml/svg/AqfDBadCIyz9LNWshVt9xcqArLmAG92IM9AOb5YSgg044JPKWeZNOfKrmYkR1vUjvIg2M_UqhVNfsXbGwn32Iaydz3tjt_1yr_xdAxgLeD8Qled59Qb52Y4PHQc9APeGCKz_L7v1QL5wAgfGG29Gn3adDJ4FJNCjkgsUUNdvBav01prjMl5qpzHda_iWxdksSO4IqDdGiB7HjOEw6m00">  
<h4 id="后台线程">后台线程</h4><p>上面看到一共有四种后台线程，每种线程都在不停地做自己的工作，他们的分工如下:</p>
<ul>
<li><code>Master Thread</code>: 是最核心的线程，主要负责将缓冲池中的数据异步刷新的磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲(INSERT BUFFER),UNDO页的回收等。下面几个线程其实是为了分担主线程的压力而在最新的版本中添加的。</li>
<li><code>IO Thread</code>: InnoDB使用大量的异步IO来处理请求。IO Thread的主要工作就是负责IO请求的回调(call back)处理。异步IO可以分为4个，分别是:write, read, insert buffer 和 log IO thread。</li>
<li><code>Purge Thread</code>: undo log是用来保证事务的，当一个事务正常提交后，这个undo log可能就不再使用了。purge thread就是用来清除这部分log已经分配的undo页的。 </li>
<li><code>Page Cleaner Thread</code>: 主要是把脏页的刷新从主线程中拿到单独的线程，减轻主线程的压力，减少用户查询线程的阻塞，提高整体性能。</li>
</ul>
<h4 id="内存">内存</h4><p>由于InnoDB是基于磁盘存储的，为了使CPU与磁盘能够快的交互，提升整体性能而采用了缓冲池技术。<br>读数据简单的说可以用下面的流程图<br><img src="http://www.plantuml.com/plantuml/svg/Aov9B2hXidgnVlUpgHkUzQwpvifCKz20i9_EMV5yp-IdRPkURLoWgL2IaPgde56PMgp9fG04LY_sJtawUnvCLsfESQg2Hbu-LFB9xhxdYnkVpvu1DFXf_pIOAh2SafjdXDBJZWrmiwsn6fYNafd6LLoINm00"><br>更新数据的流程则如下:<br><img src="http://www.plantuml.com/plantuml/svg/Aov9B2hXidgnVlVJzbtFfcvurhlEcYilloHLeIWpFQF4Ik75_fdFfczxsZ0J8lbaHyFJTREUpbdnVC_afssRdcrSy6J7sYUxshYiditUycpQ1cJXvxDQO2PQFTkzyCMspS_cBdooUzlxFJrFExO35J-TFU_vuiRdisTOSnMNv1S00000"><br>由缓冲池的作用可以看到，缓冲池越大所容纳的数据就越多，与磁盘的交互就会越少，性能也就越高。所以缓冲池的大小直接影响着数据库的整体性能。<br>InnoDB在内存中主要有以下几部分组成:<br><img src="http://www.plantuml.com/plantuml/svg/TP31IiD048RlVOeX9tqDyU8x2CkskmcBszsoZI1AmGXfFLW4sneH15FiHQYrKg5AeI_ZnEOjZDbMH9CvVz_yCx_XDPygJtBOKqhlxc0xnF5DCdXEkayuULjDOpYfG3Rc1tJIJXU3soGQuJBwNFIm_GBx2hOCPngazaZrq7MvsNRWdpYymuVhTSJqFhT45ikgX38cVA4LbQJEwwIXjIHDSSmBjjZ8pD-uDYztCjoU-pr_HVjL6h_cmOpw51hKAuoO3N4ns912CNvKXYQNLnYEVjKWL9CR7yfBw0SVopW99ZajTUq0X79r0RdgFAQdP_ZUnzuvpY_iKKx9MpYEC9pRpMkcLMbz0G00"><br>具体来看缓冲池中缓存的数据页类型有:</p>
<ul>
<li><code>索引页</code>: 缓存数据表索引</li>
<li><code>数据页</code>: 缓存数据页，占缓冲池的绝大部分</li>
<li><code>undo页</code>: undo页是保存事务，为回滚做准备的。</li>
<li><code>插入缓冲(Insert buffer)</code>: 上面提到的插入数据时要先插入到缓存池中。</li>
<li><code>自适应哈希索引(adaptive hash index)</code>: 除了B+ Tree索引外，在缓冲池还会维护一个哈希索引，以便在缓冲池中快速找到数据页。</li>
<li><code>InnoDB存储的锁信息(lock info)</code>: </li>
<li><code>数据字典(data dictionary)</code>:<br>内存中除了缓冲池外外还有:</li>
<li><code>重做日志缓冲redo log</code>: 为了避免数据丢失的问题，当前数据库系统普遍采用了write ahead log策略，既当事务提交时先写重做日志，再修改写页。当由于发生宕机而导致数据丢失时，可以通过重做日志进行恢复。InnoDB先将重做日志放到这个缓冲区，然后按照一定的频率更新到重做日志文件中。重做日志一般在下列情况下会刷新内容到文件:<ul>
<li>Master Thread每一秒将重做日志缓冲刷新到重做日志文件</li>
<li>每个事务提交时会将重做日志缓冲刷新到重做日志文件</li>
<li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件</li>
</ul>
</li>
<li><code>额外内存池</code>: InnoDB存储引擎中，对内存的管理师通过一种称为内存堆的方式进行的，在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</li>
</ul>
<p>缓冲池是一个很大的内存区域，InnoDB是如何对这些内存进行管理的呢。答案就使用LRU list。<br><a href="https://en.wikipedia.org/wiki/Page_replacement_algorithm#Variants_on_LRU" target="_blank" rel="external">LRU</a>(Latest Recent Used, 最近最少使用)算法默认的是最近使用的放到表头，最早使用的放到表尾，依次排列。当有LRU填满时有新的进来就把最早的淘汰掉。InnoDB则是在这个基础上进行了修改:</p>
<ol>
<li>最近使用的不放到表头，而是根据配置放到一定比例处，这个地方叫做midpoint, midpoint之前的成为new列表，之后的成为old列表。淘汰的同样是表尾的页。</li>
<li>为了保证new列表的不经常使用时能够淘汰，设置了一个超时时间:innodb_old_blocks_time，当数据在midpoint(我理解应该是在old列表中，不然这个点的页就一个，变化也比较频繁)的时间超过找个时间时就会被提升到表头，new列表的表尾页则被置换到old列表中。</li>
</ol>
<p>这么做的原因主要是因为常见的索引或数据的扫描操作会连续读取大量的页，甚至是全表扫描。如果采用原来的LRU算法就会更新全部的缓冲池，其他查询需要的热点数据就会被冲走，导致更多的磁盘读取操作，降低数据库的性能。<br>LRU是用来管理已经读取的页，当数据库启动时LRU是空列表,既只有表头，没有内容。这时页都放在Free List中。当需要有数据读写时要进行需要获取分页，这时要从Free List中删除分页，然后添加到LRU list中。到一定时间Free List中的分页就会被分配完毕，这时候就正常使用上面的LRU策略。<br>LRU列表中的页被修改后，称该页为脏页(dirty page),既缓冲池中的数据和磁盘上的数据产生了不一致，这时脏页会被加入到一个Flush 列表中(注意，同时存在两个列表中)。然后根据刷新的机制定时的刷新到磁盘中。</p>
<h3 id="Checkpoint技术">Checkpoint技术</h3><p>checkpoint其实就是一个刷新缓冲到磁盘的触发机制，当满足一定的条件时就会刷新缓冲到磁盘，这样做可以解决以下几个问题:</p>
<ul>
<li>缩短数据库的恢复时间: 数据库恢复可以使用redo log，但是如果要恢复的数据很多就会很慢。如果使用checkpoint刷新到磁盘，只需要从checkpoint开始恢复就可以了，所以速度会变快。</li>
<li>缓冲池不够用时，将脏页刷新到磁盘。我们知道缓冲池的大小是由限制的，为了能够高效的使用缓冲池需要把一部分数据刷新到磁盘。</li>
<li>重做日志不可用时，刷新脏页。重做日志并不是无限增大的，而是循环利用的。当有些已经不需要的页存在时可以覆盖写，当可用的页放不下时就会触发checkpoint,刷新到磁盘一部分脏页到磁盘，这样就能覆盖掉一些不再使用的重做日志。</li>
</ul>
<p>checkpoint根据触发时间，刷新页的策略又可以分为:</p>
<ul>
<li><code>sharp checkpoint</code>:刷新所有的脏页到磁盘。一般发生在数据库关闭时，为了保证所有的数据能够正常持久化。</li>
<li><code>fuzzy checkpoint</code>:只刷新部分脏页。运行时使用这种可以保证系统的性能。<h3 id="Master_Thread的工作方式">Master Thread的工作方式</h3></li>
</ul>
<h2 id="关键特性">关键特性</h2><h3 id="插入缓存">插入缓存</h3><p>这里所说的插入缓存也是Insert Buffer, 区别是这个插入缓存不是缓冲池中的插入缓存,这里的插入缓存和数据页一样，业务物理页的组成部分。在介绍插入缓存之前先了解<a href="http://www.cnblogs.com/lwzz/archive/2012/08/05/2620824.html" target="_blank" rel="external">聚集索引和非聚集索引</a>，他们之间最重要的区别就是:聚集索引的叶子节点存储的是数据，而且是按照物理顺序存储的;非聚集索引叶子节点是地址(也就是聚集索引键地址)，是按照逻辑顺序存储的(以上言论是从网上了解到的，但是本书P194特别指出，聚集索引也不是按照物理地址连续的，而是逻辑上连续的)。<br>知道这个差别后就知道，当不停的插入数据时，如果是聚集索引的数据，按照物理顺序(这个应该是一般情况下，因为是一般聚集索引是主键，顺序递增的，所以这时候地址就是顺序的)连续插入，代价比较小。而如果是非聚集索引的插入则物理地址是离散的，会导致很大的系统开销，所以对于非聚集索引InnoDB开创性设计了Insert Buffer。使用InnoDB的Insert Buffer需要以下两个条件:</p>
<ul>
<li>索引是辅助索引(非聚集索引 secondary index);</li>
<li>索引不是唯一(unique)的。</li>
</ul>
<p>Insert Buffer的使用流程是:<br><img src="http://www.plantuml.com/plantuml/svg/LKvB2e906DxFAMPfLz1TkuuHD98G5iwqQ5U14j6Bx06zo22em5wOA5YdyH_r5WtOfc_vlIah6mp9V3m5yyXx2xxs-EAk84t5KhRTfPrLjhOIxm3HF7DUi3abaGtMap_sSU0MCAiI7KijGWi82yY9Y8-EUPk2I8qIBEdrdyXd7q77GJiEBYMT4eFXObDLYG6tC7queb39ZN1TyQN_RvaEqey9_NF-1SO-k9Eqtqsw8Knw4FhS7iRlZTZKAvgAAAitlW00"><br>要求索引不是唯一的是因为如果索引是唯一的，那么每次更新都要坚持是不是已经存在，每次还是要访问数据页，这就失去了使用Insert Buffer的优势。<br>后面还提到了Update buffer以及Merge的过程和Insert Buffer的实现，这里就不再一一说了。</p>
<h3 id="两次写">两次写</h3><p>上面提到的Insert Buffer是提高了数据库的性能，doublewrite则是提高了数据库的可靠性。一个场景是当一个16k的数据页只写了一部分,比如4k,这时候突然断电，就会导致这个页的数据不全。所以就会导致这个页的数据丢失。我们知道重做日志是用来恢复数据的，但是重做日志记录的是对页的物理操作，如果这个页已经发生了损坏在对其进行重做是没有意义的。</p>
<blockquote>
<p>上面这段话，其实我并没有看懂，因为对页操作之前是先写重做日志的，当发生宕机时正在写数据页，证明这时候重做日志已经写完了。这时重做日志的记录的完整的，当用这个记录去恢复数据时，不管页是不是损坏，重做日志直接覆盖不就行了么？为什么不行呢？等到后面我更加深入的了解后再来补充。</p>
</blockquote>
<p>doublewrite有两部分组成，一部分是内存中的doublewrite buffer, 大小为2MB,另一部分是物理磁盘上共享表空间中连续的128个页，既两个区，大小同样为2MB<br>。对缓冲池的脏页进行刷新时，比不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer, 之后通过doublewrite buffer再分两次，每次1MB的写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件中。</p>
<p>如果磁盘写入时发生崩溃，可以从共享表空间的doublewrite中找到副本，将其复制到表空间文件，再应用重做日志。</p>
<blockquote>
<p>这个地方也有一个疑问，当doublewrite写入的过程中发生了崩溃，这时候数据该怎么办呢？</p>
</blockquote>
<h3 id="自适应哈希索引">自适应哈希索引</h3><p>对于缓冲池中的页，为了能够快速的查找，InnoDB跟情况对其建立了一个hash index。这样对于等值查询就能够利用这个索引更加快速的查找，提高了查找的性能。</p>
<h3 id="异步IO">异步IO</h3><p>为了提高磁盘的操作性能，当前的数据库系统都采用异步IO的方式处理磁盘操作。用户可以在发出一个IO请求胡立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作完成，这就是AIO。<br>AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO, 这样可以提高IOPS的性能。</p>
<h3 id="刷新临近页">刷新临近页</h3><p>Flush Neighbor Page(刷新临近页)是当刷新一个脏页时，InnoDB会检测该页所在区的所有页，如果是脏页，那么一起进行刷新。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/mysql/">mysql</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="2015/10/14/InnoDB-Key-Features/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2017 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>